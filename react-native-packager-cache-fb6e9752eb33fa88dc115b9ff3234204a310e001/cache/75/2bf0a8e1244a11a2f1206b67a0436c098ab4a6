Object.defineProperty(exports,"__esModule",{value:true});

















var _BaseView=require("./BaseView");var _BaseView2=babelHelpers.interopRequireDefault(_BaseView);
var _merge=require("../Utils/merge");var _merge2=babelHelpers.interopRequireDefault(_merge);
var _StereoOffsetRepeats=require("../Utils/StereoOffsetRepeats");var _StereoOffsetRepeats2=babelHelpers.interopRequireDefault(_StereoOffsetRepeats);
var _HPano=require("../Utils/HPano");
var _CubePano=require("../Utils/CubePano");
var _RCTBindedResource=require("../Utils/RCTBindedResource");
var _ovrui=require("ovrui");var OVRUI=babelHelpers.interopRequireWildcard(_ovrui);
var _three=require("three");var THREE=babelHelpers.interopRequireWildcard(_three);
var _Yoga=require("../Utils/Yoga.bundle");var Yoga=babelHelpers.interopRequireWildcard(_Yoga);

var _Prefetch=require("./Prefetch");var _Prefetch2=babelHelpers.interopRequireDefault(_Prefetch);/**
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *//**
 * RCTPano: runtime implementation of the <Pano source={{uri:URL}}>
 * creates a 1000 m radius globe that as a child of the view
 * view responds to layout and transforms with pivot point the center
 * of the view
 * @class RCTPano
 * @extends RCTBaseView
 */var panoRayCast=function(){// avoid create temp objects;
var inverseMatrix=new THREE.Matrix4();var ray=new THREE.Ray();var sphere=new THREE.Sphere(new THREE.Vector3(0,0,0),1000);var intersectionPoint=new THREE.Vector3();var intersectionPointWorld=new THREE.Vector3();return function(raycaster,intersects){// transform the ray into the space of the sphere
inverseMatrix.getInverse(this.matrixWorld);ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);var intersect=ray.intersectSphere(sphere,intersectionPoint);if(intersect===null){return;}

// determine hit location in world space
intersectionPointWorld.copy(intersectionPoint);
intersectionPointWorld.applyMatrix4(this.matrixWorld);

var distance=raycaster.ray.origin.distanceTo(intersectionPointWorld);
if(distance<raycaster.near||distance>raycaster.far){
return;
}

intersects.push({
distance:distance,
point:intersectionPointWorld.clone(),
object:this});

};
}();

var sphereGeometry=undefined;
var cubeGeometry=undefined;var

RCTPano=function(_RCTBaseView){babelHelpers.inherits(RCTPano,_RCTBaseView);
/**
   * constructor: allocates the required resources and sets defaults
   */
function RCTPano(guiSys,rnctx){babelHelpers.classCallCheck(this,RCTPano);var _this=babelHelpers.possibleConstructorReturn(this,(RCTPano.__proto__||Object.getPrototypeOf(RCTPano)).call(this));


sphereGeometry=sphereGeometry||new THREE.SphereGeometry(1000,50,50);
cubeGeometry=cubeGeometry||new _CubePano.CubePanoBufferGeometry(2000,3,2,1.01);

_this._tintOpacity=1.0;
_this._styleOpacity=1.0;
_this._sphereGeometry=sphereGeometry;
_this._cubeGeometry=cubeGeometry;
_this._material=new OVRUI.StereoBasicTextureMaterial({
color:'white',
side:THREE.DoubleSide});


_this._globe=new THREE.Mesh(_this._sphereGeometry,_this._material);
_this._globe.onBeforeRender=function(renderer,scene,camera,geometry,material,group){
if(camera.viewID===1&&material.stereoOffsetRepeats[1]){
material.uniforms.stereoOffsetRepeat.value=material.stereoOffsetRepeats[1];
}else{
material.uniforms.stereoOffsetRepeat.value=material.stereoOffsetRepeats[0];
}
if(material._rightEnvMap){
if(camera.viewID===1){
material.envMap=material._rightEnvMap;
}else{
material.envMap=material._leftEnvMap;
}
material.needsUpdate=true;
}
};

_this._globe.raycast=panoRayCast.bind(_this._globe);
_this._globe.rotation.y=-Math.PI/2;

_this.view=new OVRUI.UIView(guiSys);
// set zOffset to be the radius of the sphere. This helps prevent the pano's
// transparency from affecting other views as a result of rendering order.
_this.view.zOffset=1000;
_this.view.add(_this._globe);
_this._localResource=new _RCTBindedResource.RCTBindedResource(rnctx.RCTResourceManager);
_this.globeOnUpdate=_this.globeOnUpdate.bind(_this);

Object.defineProperty(_this.props,'source',{
set:function set(value){return _this.setSource(value);}});

// register a setter for the backgroundColor so the globe can be tinted
Object.defineProperty(_this.style,'opacity',{
set:function set(value){
_this._styleOpacity=value;
_this._material.opacity=_this._styleOpacity*_this._tintOpacity;
_this._material.transparent=_this._material.opacity<1;
}});

// register a setter for the backgroundColor so the globe can be tinted
Object.defineProperty(_this.style,'tintColor',{
set:function set(value){
var opacity=parseInt(value.toString(16).slice(0,2),16)/255;
_this._material.color.set(value);
_this._tintOpacity=opacity;
_this._material.opacity=_this._styleOpacity*_this._tintOpacity;
_this._material.transparent=_this._material.opacity<1;
}});return _this;

}babelHelpers.createClass(RCTPano,[{key:"globeOnUpdate",value:function globeOnUpdate(

scene,camera){
var projScreenMatrix=new THREE.Matrix4();
var modelViewMatrix=new THREE.Matrix4();
modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse,this._globe.matrixWorld);
projScreenMatrix.multiplyMatrices(camera.projectionMatrix,modelViewMatrix);
this._globe.geometry.update(this.maxDepth,projScreenMatrix);
this._globe.material=this._globe.geometry.material;
}},{key:"setSource",value:function setSource(

value){var _this2=this;
if(value&&value.tile){
// use tile renderer
this._globe.geometry.dispose();
this.maxDepth=value.maxDepth||2;
this._globe.geometry=new _HPano.HPanoBufferGeometry(1000,this.maxDepth,value.tile);
this._globe.onUpdate=this.globeOnUpdate;
}else{
// use sphere renderer
this._globe.geometry.dispose();
if(value&&value.layout==='CUBEMAP_32'){
this._globe.geometry=this._cubeGeometry;
this._globe.scale.z=-1;
this._material.useUV=1;
}else{
this._globe.geometry=this._sphereGeometry;
this._globe.scale.z=1;
this._material.useUV=0;
}
this._globe.onUpdate=null;
// call onLoadStart in React
this.UIManager._rnctx.callFunction('RCTEventEmitter','receiveEvent',[
this.getTag(),
'topLoadStart',
[]]);

var loadRemoteTexture=function loadRemoteTexture(url,onLoad,viewID){
// When a url is null or undefined, send undefined to onLoad callback
var onError=function onError(){return onLoad(undefined,viewID);};
var onLoadDisposable=function onLoadDisposable(texture){
texture._needsDispose=true;
onLoad(texture,viewID);
};
// No progress indication for now.
var onProgress=undefined;
if(url==null){
onError();
}else if(_Prefetch2.default.isCached(url)){
// First Check if the texture hasn't already been prefetched
var cachedTexture=_Prefetch2.default.getFromCache(url);
onLoad(cachedTexture,viewID);
}else if(Array.isArray(url)){
var loader=new THREE.CubeTextureLoader();
loader.setCrossOrigin('Access-Control-Allow-Origin');
loader.load(url,onLoadDisposable,onProgress,onError);
}else{
var _loader=new THREE.TextureLoader();
_loader.setCrossOrigin('Access-Control-Allow-Origin');
_loader.load(url,onLoadDisposable,onProgress,onError);
}
};
var onLoadOrChange=function onLoadOrChange(texture,viewID){
// ignore a old request result
if(value!==_this2._currentSource){
return;
}
_this2._globe.scale.x=-1;
// Only dispose certain textures, not those that have been
// prefetched or from video. A texture manager would be useful
// to help track the lifetime of textures.
if(_this2._material.map&&_this2._material.map._needsDispose){
_this2._material.map.dispose();
}
if(
_this2._material.envMap&&
_this2._material.envMap._needsDispose&&
_this2._material.envMap!==_this2._material._leftEnvMap&&
_this2._material.envMap!==_this2._material._rightEnvMap)
{
_this2._material.envMap.dispose();
}
if(texture===undefined){
_this2._material.map=undefined;
_this2._material.envMap=undefined;
}else if(texture.type==='MonoTextureInfo'){
_this2._material.map=texture.texture;
_this2._material.envMap=undefined;
}else{
if(!value.enableMipmaps){
texture.generateMipmaps=false;
texture.minFilter=THREE.LinearFilter;
}
texture.wrapS=THREE.ClampToEdgeWrapping;
texture.wrapT=THREE.ClampToEdgeWrapping;
var cubeTexture=texture.isCubeTexture?texture:null;
var flatTexture=texture.isCubeTexture?null:texture;
if(texture.isCubeTexture){
_this2._globe.scale.x=1;
}
_this2._material.map=flatTexture;
_this2._material.envMap=cubeTexture;
if(viewID===1){
_this2._nextRightEnvMap=cubeTexture;
}else{
_this2._nextLeftEnvMap=cubeTexture;
}
}
var stereoFormat=value&&value.stereo?value.stereo:'2D';
_this2._material.stereoOffsetRepeats=_StereoOffsetRepeats2.default[stereoFormat];
if(!_this2._material.stereoOffsetRepeats){
console.warn("Pano: stereo format '"+stereoFormat+"' not supported.");
// fallback to 2D
_this2._material.stereoOffsetRepeats=_StereoOffsetRepeats2.default['2D'];
}
_this2._material.needsUpdate=true;

_this2._numTexturesToLoad--;
if(_this2._numTexturesToLoad===0){
if(_this2._material._leftEnvMap&&_this2._material._leftEnvMap._needsDispose){
_this2._material._leftEnvMap.dispose();
}
if(_this2._material._rightEnvMap&&_this2._material._rightEnvMap._needsDispose){
_this2._material._rightEnvMap.dispose();
}
_this2._material._leftEnvMap=_this2._nextLeftEnvMap;
_this2._material._rightEnvMap=_this2._nextRightEnvMap;
// call onLoad in React
if(texture!==undefined){
_this2.UIManager._rnctx.callFunction('RCTEventEmitter','receiveEvent',[
_this2.getTag(),
'topLoad',
[]]);

}
// call onLoadEvent in React
_this2.UIManager._rnctx.callFunction('RCTEventEmitter','receiveEvent',[
_this2.getTag(),
'topLoadEnd',
[]]);

}
};

this._currentSource=value;
this._numTexturesToLoad=1;
this._nextLeftEnvMap=undefined;
this._nextRightEnvMap=undefined;
if(Array.isArray(value)){
if(value.length!==6&&value.length!==12||!value[0].uri){
console.warn("Pano expected cubemap source in format [{uri: http..}, {uri: http..}, ... ]with length of 6 (or 12 for stereo)");



return;
}
var urls=value.map(function(x){
return x.uri;
});
this._localResource.unregister();
if(urls.length===12){
this._numTexturesToLoad=2;
loadRemoteTexture(urls.slice(0,6),onLoadOrChange,0);
loadRemoteTexture(urls.slice(6,12),onLoadOrChange,1);
}else{
loadRemoteTexture(urls,onLoadOrChange,0);
}
}else{
var url=value?value.uri:null;
if(this._localResource.isValidUrl(url)){
this._localResource.load(url,function(texture){return onLoadOrChange(texture,0);});
}else{
this._localResource.unregister();
loadRemoteTexture(url,onLoadOrChange,0);
}
}
}
}},{key:"presentLayout",value:function presentLayout()

{
babelHelpers.get(RCTPano.prototype.__proto__||Object.getPrototypeOf(RCTPano.prototype),"presentLayout",this).call(this);
this._globe.visible=this.YGNode.getDisplay()!==Yoga.DISPLAY_NONE;
}

/**
   * Dispose of any associated resources
   */},{key:"dispose",value:function dispose()
{
if(this._localResource){
this._localResource.dispose();
}
babelHelpers.get(RCTPano.prototype.__proto__||Object.getPrototypeOf(RCTPano.prototype),"dispose",this).call(this);
}

/**
   * Describes the properties representable by this view type and merges
   * with super type
   */}],[{key:"describe",value:function describe()
{
return(0,_merge2.default)(babelHelpers.get(RCTPano.__proto__||Object.getPrototypeOf(RCTPano),"describe",this).call(this),{
// declare the native props sent from react to runtime
NativeProps:{
source:'string'}});


}}]);return RCTPano;}(_BaseView2.default);exports.default=RCTPano;