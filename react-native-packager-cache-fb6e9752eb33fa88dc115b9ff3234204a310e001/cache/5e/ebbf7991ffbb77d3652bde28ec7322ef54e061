Object.defineProperty(exports,"__esModule",{value:true});










var _BaseMesh=require("./BaseMesh");var _BaseMesh2=babelHelpers.interopRequireDefault(_BaseMesh);
var _three=require("three");var THREE=babelHelpers.interopRequireWildcard(_three);
var _merge=require("../Utils/merge");var _merge2=babelHelpers.interopRequireDefault(_merge);




var SphereGeometryCache={};/**
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */function createSphereGeometry(radius,heightSegments,widthSegments){var key=radius+":"+heightSegments+":"+widthSegments;var cache=SphereGeometryCache[key];if(cache){cache.count++;return cache.geom;}var geometry=new THREE.SphereBufferGeometry(radius,widthSegments,heightSegments);

SphereGeometryCache[key]={
geom:geometry,
count:1};


return geometry;
}

var sphereRayCast=function(){
// avoid create temp objects;
var inverseMatrix=new THREE.Matrix4();
var ray=new THREE.Ray();
var intersectionPoint=new THREE.Vector3();
var intersectionPointWorld=new THREE.Vector3();
return function(sphere,raycaster,intersects){
// transform the ray into the space of the sphere
inverseMatrix.getInverse(this.matrixWorld);
ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
var intersect=ray.intersectSphere(sphere,intersectionPoint);
if(intersect===null){
return;
}

// determine hit location in world space
intersectionPointWorld.copy(intersectionPoint);
intersectionPointWorld.applyMatrix4(this.matrixWorld);

var distance=raycaster.ray.origin.distanceTo(intersectionPointWorld);
if(distance<raycaster.near||distance>raycaster.far){
return;
}

intersects.push({
distance:distance,
point:intersectionPointWorld.clone(),
object:this});

};
}();var

RCTSphere=function(_RCTBaseMesh){babelHelpers.inherits(RCTSphere,_RCTBaseMesh);





function RCTSphere(guiSys,rnctx){babelHelpers.classCallCheck(this,RCTSphere);var _this=babelHelpers.possibleConstructorReturn(this,(RCTSphere.__proto__||Object.getPrototypeOf(RCTSphere)).call(this,
guiSys,rnctx));

_this._radius=0.5;
_this._heightSegments=6;
_this._widthSegments=8;
_this._needsUpdate=false;

Object.defineProperty(
_this.props,
'radius',
{
set:function set(radius){
_this._radius=radius;
_this._needsUpdate=true;
}});



Object.defineProperty(
_this.props,
'heightSegments',
{
set:function set(segments){
_this._heightSegments=segments;
_this._needsUpdate=true;
}});



Object.defineProperty(
_this.props,
'widthSegments',
{
set:function set(segments){
_this._widthSegments=segments;
_this._needsUpdate=true;
}});



_this._generateGeometry=_this._generateGeometry.bind(_this);return _this;
}babelHelpers.createClass(RCTSphere,[{key:"frame",value:function frame()

{
if(this._needsUpdate){
this._needsUpdate=false;
this._generateGeometry();
}
}},{key:"_generateGeometry",value:function _generateGeometry()

{
var geometry=createSphereGeometry(this._radius,this._widthSegments,this._heightSegments);
this._setGeometry(geometry);
var sphere=new THREE.Sphere(new THREE.Vector3(0,0,0),this._radius);
this.mesh.raycast=sphereRayCast.bind(this.mesh,sphere);
}}],[{key:"describe",value:function describe()

{
return(0,_merge2.default)(babelHelpers.get(RCTSphere.__proto__||Object.getPrototypeOf(RCTSphere),"describe",this).call(this),{
// register the properties sent from react to runtime
NativeProps:{
radius:'number',
widthSegments:'number',
heightSegments:'number'}});


}}]);return RCTSphere;}(_BaseMesh2.default);exports.default=RCTSphere;