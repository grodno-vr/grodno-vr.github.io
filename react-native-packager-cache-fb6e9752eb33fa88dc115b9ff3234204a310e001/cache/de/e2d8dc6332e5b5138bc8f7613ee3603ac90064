/**
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule AnimatedImplementation
 * 
 * @preventMunge
 */
'use strict';

var InteractionManager=require('InteractionManager');
var Interpolation=require('Interpolation');
var NativeAnimatedHelper=require('NativeAnimatedHelper');
var React=require('React');
var ReactNative=require('ReactNative');
var Set=require('Set');
var SpringConfig=require('SpringConfig');
var ViewStylePropTypes=require('ViewStylePropTypes');

var flattenStyle=require('flattenStyle');
var invariant=require('fbjs/lib/invariant');
var requestAnimationFrame=require('fbjs/lib/requestAnimationFrame');






var NativeAnimatedAPI=NativeAnimatedHelper.API;

var warnedMissingNativeAnimated=false;

function shouldUseNativeDriver(config){
if(config.useNativeDriver&&
!NativeAnimatedHelper.isNativeAnimatedAvailable()){
if(!warnedMissingNativeAnimated){
console.warn("Animated: `useNativeDriver` is not supported because the native animated module is missing. Falling back to JS-based animation. To resolve this, add `RCTAnimation` module to this app, or remove `useNativeDriver`. More info: https://github.com/facebook/react-native/issues/11094#issuecomment-263240420");






warnedMissingNativeAnimated=true;
}
return false;
}

return config.useNativeDriver||false;
}

// Note(vjeux): this would be better as an interface but flow doesn't
// support them yet
var Animated=function(){function Animated(){babelHelpers.classCallCheck(this,Animated);}babelHelpers.createClass(Animated,[{key:"__attach",value:function __attach()
{}},{key:"__detach",value:function __detach()
{
if(this.__isNative&&this.__nativeTag!=null){
NativeAnimatedAPI.dropAnimatedNode(this.__nativeTag);
this.__nativeTag=undefined;
}
}},{key:"__getValue",value:function __getValue()
{}},{key:"__getAnimatedValue",value:function __getAnimatedValue()
{return this.__getValue();}},{key:"__addChild",value:function __addChild(
child){}},{key:"__removeChild",value:function __removeChild(
child){}},{key:"__getChildren",value:function __getChildren()
{return[];}

/* Methods and props used by native Animated impl */},{key:"__makeNative",value:function __makeNative()


{
if(!this.__isNative){
throw new Error('This node cannot be made a "native" animated node');
}
}},{key:"__getNativeTag",value:function __getNativeTag()
{
NativeAnimatedHelper.assertNativeAnimatedModule();
invariant(this.__isNative,'Attempt to get native tag from node not marked as "native"');
if(this.__nativeTag==null){
var nativeTag=NativeAnimatedHelper.generateNewNodeTag();
NativeAnimatedAPI.createAnimatedNode(nativeTag,this.__getNativeConfig());
this.__nativeTag=nativeTag;
}
return this.__nativeTag;
}},{key:"__getNativeConfig",value:function __getNativeConfig()
{
throw new Error('This JS animated node type cannot be used as native animated node');
}},{key:"toJSON",value:function toJSON()
{return this.__getValue();}}]);return Animated;}();









// Important note: start() and stop() will only be called at most once.
// Once an animation has been stopped or finished its course, it will
// not be reused.
var Animation=function(){function Animation(){babelHelpers.classCallCheck(this,Animation);}babelHelpers.createClass(Animation,[{key:"start",value:function start(






fromValue,
onUpdate,
onEnd,
previousAnimation,
animatedValue)
{}},{key:"stop",value:function stop()
{
if(this.__nativeId){
NativeAnimatedAPI.stopAnimation(this.__nativeId);
}
}},{key:"__getNativeAnimationConfig",value:function __getNativeAnimationConfig()
{
// Subclasses that have corresponding animation implementation done in native
// should override this method
throw new Error('This animation type cannot be offloaded to native');
}
// Helper function for subclasses to make sure onEnd is only called once.
},{key:"__debouncedOnEnd",value:function __debouncedOnEnd(result){
var onEnd=this.__onEnd;
this.__onEnd=null;
onEnd&&onEnd(result);
}},{key:"__startNativeAnimation",value:function __startNativeAnimation(
animatedValue){
animatedValue.__makeNative();
this.__nativeId=NativeAnimatedHelper.generateNewAnimationId();
NativeAnimatedAPI.startAnimatingNode(
this.__nativeId,
animatedValue.__getNativeTag(),
this.__getNativeAnimationConfig(),
this.__debouncedOnEnd.bind(this));

}}]);return Animation;}();var


AnimatedWithChildren=function(_Animated){babelHelpers.inherits(AnimatedWithChildren,_Animated);


function AnimatedWithChildren(){babelHelpers.classCallCheck(this,AnimatedWithChildren);var _this=babelHelpers.possibleConstructorReturn(this,(AnimatedWithChildren.__proto__||Object.getPrototypeOf(AnimatedWithChildren)).call(this));

_this._children=[];return _this;
}babelHelpers.createClass(AnimatedWithChildren,[{key:"__makeNative",value:function __makeNative()

{
if(!this.__isNative){
this.__isNative=true;
for(var _iterator=this._children,_isArray=Array.isArray(_iterator),_i=0,_iterator=_isArray?_iterator:_iterator[typeof Symbol==="function"?Symbol.iterator:"@@iterator"]();;){var _ref;if(_isArray){if(_i>=_iterator.length)break;_ref=_iterator[_i++];}else{_i=_iterator.next();if(_i.done)break;_ref=_i.value;}var child=_ref;
child.__makeNative();
NativeAnimatedAPI.connectAnimatedNodes(this.__getNativeTag(),child.__getNativeTag());
}
}
}},{key:"__addChild",value:function __addChild(

child){
if(this._children.length===0){
this.__attach();
}
this._children.push(child);
if(this.__isNative){
// Only accept "native" animated nodes as children
child.__makeNative();
NativeAnimatedAPI.connectAnimatedNodes(this.__getNativeTag(),child.__getNativeTag());
}
}},{key:"__removeChild",value:function __removeChild(

child){
var index=this._children.indexOf(child);
if(index===-1){
console.warn('Trying to remove a child that doesn\'t exist');
return;
}
if(this.__isNative&&child.__isNative){
NativeAnimatedAPI.disconnectAnimatedNodes(this.__getNativeTag(),child.__getNativeTag());
}
this._children.splice(index,1);
if(this._children.length===0){
this.__detach();
}
}},{key:"__getChildren",value:function __getChildren()

{
return this._children;
}}]);return AnimatedWithChildren;}(Animated);


/**
 * Animated works by building a directed acyclic graph of dependencies
 * transparently when you render your Animated components.
 *
 *               new Animated.Value(0)
 *     .interpolate()        .interpolate()    new Animated.Value(1)
 *         opacity               translateY      scale
 *          style                         transform
 *         View#234                         style
 *                                         View#123
 *
 * A) Top Down phase
 * When an Animated.Value is updated, we recursively go down through this
 * graph in order to find leaf nodes: the views that we flag as needing
 * an update.
 *
 * B) Bottom Up phase
 * When a view is flagged as needing an update, we recursively go back up
 * in order to build the new value that it needs. The reason why we need
 * this two-phases process is to deal with composite props such as
 * transform which can receive values from multiple parents.
 */
function _flush(rootNode){
var animatedStyles=new Set();
function findAnimatedStyles(node){
if(typeof node.update==='function'){
animatedStyles.add(node);
}else{
node.__getChildren().forEach(findAnimatedStyles);
}
}
findAnimatedStyles(rootNode);
/* $FlowFixMe */
animatedStyles.forEach(function(animatedStyle){return animatedStyle.update();});
}















var _easeInOut=void 0;
function easeInOut(){
if(!_easeInOut){
var Easing=require('Easing');
_easeInOut=Easing.inOut(Easing.ease);
}
return _easeInOut;
}var

TimingAnimation=function(_Animation){babelHelpers.inherits(TimingAnimation,_Animation);











function TimingAnimation(
config)
{babelHelpers.classCallCheck(this,TimingAnimation);var _this2=babelHelpers.possibleConstructorReturn(this,(TimingAnimation.__proto__||Object.getPrototypeOf(TimingAnimation)).call(this));

_this2._toValue=config.toValue;
_this2._easing=config.easing!==undefined?config.easing:easeInOut();
_this2._duration=config.duration!==undefined?config.duration:500;
_this2._delay=config.delay!==undefined?config.delay:0;
_this2.__iterations=config.iterations!==undefined?config.iterations:1;
_this2.__isInteraction=config.isInteraction!==undefined?config.isInteraction:true;
_this2._useNativeDriver=shouldUseNativeDriver(config);return _this2;
}babelHelpers.createClass(TimingAnimation,[{key:"__getNativeAnimationConfig",value:function __getNativeAnimationConfig()

{
var frameDuration=16.666666666666668;
var frames=[];
for(var dt=0.0;dt<this._duration;dt+=frameDuration){
frames.push(this._easing(dt/this._duration));
}
frames.push(this._easing(1));
return{
type:'frames',
frames:frames,
toValue:this._toValue,
iterations:this.__iterations};

}},{key:"start",value:function start(


fromValue,
onUpdate,
onEnd,
previousAnimation,
animatedValue)
{var _this3=this;
this.__active=true;
this._fromValue=fromValue;
this._onUpdate=onUpdate;
this.__onEnd=onEnd;

var start=function start(){
// Animations that sometimes have 0 duration and sometimes do not
// still need to use the native driver when duration is 0 so as to
// not cause intermixed JS and native animations.
if(_this3._duration===0&&!_this3._useNativeDriver){
_this3._onUpdate(_this3._toValue);
_this3.__debouncedOnEnd({finished:true});
}else{
_this3._startTime=Date.now();
if(_this3._useNativeDriver){
_this3.__startNativeAnimation(animatedValue);
}else{
_this3._animationFrame=requestAnimationFrame(_this3.onUpdate.bind(_this3));
}
}
};
if(this._delay){
this._timeout=setTimeout(start,this._delay);
}else{
start();
}
}},{key:"onUpdate",value:function onUpdate()

{
var now=Date.now();
if(now>=this._startTime+this._duration){
if(this._duration===0){
this._onUpdate(this._toValue);
}else{
this._onUpdate(
this._fromValue+this._easing(1)*(this._toValue-this._fromValue));

}
this.__debouncedOnEnd({finished:true});
return;
}

this._onUpdate(
this._fromValue+
this._easing((now-this._startTime)/this._duration)*(
this._toValue-this._fromValue));

if(this.__active){
this._animationFrame=requestAnimationFrame(this.onUpdate.bind(this));
}
}},{key:"stop",value:function stop()

{
babelHelpers.get(TimingAnimation.prototype.__proto__||Object.getPrototypeOf(TimingAnimation.prototype),"stop",this).call(this);
this.__active=false;
clearTimeout(this._timeout);
global.cancelAnimationFrame(this._animationFrame);
this.__debouncedOnEnd({finished:false});
}}]);return TimingAnimation;}(Animation);var












DecayAnimation=function(_Animation2){babelHelpers.inherits(DecayAnimation,_Animation2);









function DecayAnimation(
config)
{babelHelpers.classCallCheck(this,DecayAnimation);var _this4=babelHelpers.possibleConstructorReturn(this,(DecayAnimation.__proto__||Object.getPrototypeOf(DecayAnimation)).call(this));

_this4._deceleration=config.deceleration!==undefined?config.deceleration:0.998;
_this4._velocity=config.velocity;
_this4._useNativeDriver=shouldUseNativeDriver(config);
_this4.__isInteraction=config.isInteraction!==undefined?config.isInteraction:true;
_this4.__iterations=config.iterations!==undefined?config.iterations:1;return _this4;
}babelHelpers.createClass(DecayAnimation,[{key:"__getNativeAnimationConfig",value:function __getNativeAnimationConfig()

{
return{
type:'decay',
deceleration:this._deceleration,
velocity:this._velocity,
iterations:this.__iterations};

}},{key:"start",value:function start(


fromValue,
onUpdate,
onEnd,
previousAnimation,
animatedValue)
{
this.__active=true;
this._lastValue=fromValue;
this._fromValue=fromValue;
this._onUpdate=onUpdate;
this.__onEnd=onEnd;
this._startTime=Date.now();
if(this._useNativeDriver){
this.__startNativeAnimation(animatedValue);
}else{
this._animationFrame=requestAnimationFrame(this.onUpdate.bind(this));
}
}},{key:"onUpdate",value:function onUpdate()

{
var now=Date.now();

var value=this._fromValue+
this._velocity/(1-this._deceleration)*(
1-Math.exp(-(1-this._deceleration)*(now-this._startTime)));

this._onUpdate(value);

if(Math.abs(this._lastValue-value)<0.1){
this.__debouncedOnEnd({finished:true});
return;
}

this._lastValue=value;
if(this.__active){
this._animationFrame=requestAnimationFrame(this.onUpdate.bind(this));
}
}},{key:"stop",value:function stop()

{
babelHelpers.get(DecayAnimation.prototype.__proto__||Object.getPrototypeOf(DecayAnimation.prototype),"stop",this).call(this);
this.__active=false;
global.cancelAnimationFrame(this._animationFrame);
this.__debouncedOnEnd({finished:false});
}}]);return DecayAnimation;}(Animation);


























function withDefault(value,defaultValue){
if(value===undefined||value===null){
return defaultValue;
}
return value;
}var

SpringAnimation=function(_Animation3){babelHelpers.inherits(SpringAnimation,_Animation3);
















function SpringAnimation(
config)
{babelHelpers.classCallCheck(this,SpringAnimation);var _this5=babelHelpers.possibleConstructorReturn(this,(SpringAnimation.__proto__||Object.getPrototypeOf(SpringAnimation)).call(this));


_this5._overshootClamping=withDefault(config.overshootClamping,false);
_this5._restDisplacementThreshold=withDefault(config.restDisplacementThreshold,0.001);
_this5._restSpeedThreshold=withDefault(config.restSpeedThreshold,0.001);
_this5._initialVelocity=config.velocity;
_this5._lastVelocity=withDefault(config.velocity,0);
_this5._toValue=config.toValue;
_this5._useNativeDriver=shouldUseNativeDriver(config);
_this5.__isInteraction=config.isInteraction!==undefined?config.isInteraction:true;
_this5.__iterations=config.iterations!==undefined?config.iterations:1;

var springConfig;
if(config.bounciness!==undefined||config.speed!==undefined){
invariant(
config.tension===undefined&&config.friction===undefined,
'You can only define bounciness/speed or tension/friction but not both');

springConfig=SpringConfig.fromBouncinessAndSpeed(
withDefault(config.bounciness,8),
withDefault(config.speed,12));

}else{
springConfig=SpringConfig.fromOrigamiTensionAndFriction(
withDefault(config.tension,40),
withDefault(config.friction,7));

}
_this5._tension=springConfig.tension;
_this5._friction=springConfig.friction;return _this5;
}babelHelpers.createClass(SpringAnimation,[{key:"__getNativeAnimationConfig",value:function __getNativeAnimationConfig()

{
return{
type:'spring',
overshootClamping:this._overshootClamping,
restDisplacementThreshold:this._restDisplacementThreshold,
restSpeedThreshold:this._restSpeedThreshold,
tension:this._tension,
friction:this._friction,
initialVelocity:withDefault(this._initialVelocity,this._lastVelocity),
toValue:this._toValue,
iterations:this.__iterations};

}},{key:"start",value:function start(


fromValue,
onUpdate,
onEnd,
previousAnimation,
animatedValue)
{
this.__active=true;
this._startPosition=fromValue;
this._lastPosition=this._startPosition;

this._onUpdate=onUpdate;
this.__onEnd=onEnd;
this._lastTime=Date.now();

if(previousAnimation instanceof SpringAnimation){
var internalState=previousAnimation.getInternalState();
this._lastPosition=internalState.lastPosition;
this._lastVelocity=internalState.lastVelocity;
this._lastTime=internalState.lastTime;
}
if(this._initialVelocity!==undefined&&
this._initialVelocity!==null){
this._lastVelocity=this._initialVelocity;
}
if(this._useNativeDriver){
this.__startNativeAnimation(animatedValue);
}else{
this.onUpdate();
}
}},{key:"getInternalState",value:function getInternalState()

{
return{
lastPosition:this._lastPosition,
lastVelocity:this._lastVelocity,
lastTime:this._lastTime};

}},{key:"onUpdate",value:function onUpdate()

{
var position=this._lastPosition;
var velocity=this._lastVelocity;

var tempPosition=this._lastPosition;
var tempVelocity=this._lastVelocity;

// If for some reason we lost a lot of frames (e.g. process large payload or
// stopped in the debugger), we only advance by 4 frames worth of
// computation and will continue on the next frame. It's better to have it
// running at faster speed than jumping to the end.
var MAX_STEPS=64;
var now=Date.now();
if(now>this._lastTime+MAX_STEPS){
now=this._lastTime+MAX_STEPS;
}

// We are using a fixed time step and a maximum number of iterations.
// The following post provides a lot of thoughts into how to build this
// loop: http://gafferongames.com/game-physics/fix-your-timestep/
var TIMESTEP_MSEC=1;
var numSteps=Math.floor((now-this._lastTime)/TIMESTEP_MSEC);

for(var i=0;i<numSteps;++i){
// Velocity is based on seconds instead of milliseconds
var step=TIMESTEP_MSEC/1000;

// This is using RK4. A good blog post to understand how it works:
// http://gafferongames.com/game-physics/integration-basics/
var aVelocity=velocity;
var aAcceleration=this._tension*(
this._toValue-tempPosition)-this._friction*tempVelocity;
var tempPosition=position+aVelocity*step/2;
var tempVelocity=velocity+aAcceleration*step/2;

var bVelocity=tempVelocity;
var bAcceleration=this._tension*(
this._toValue-tempPosition)-this._friction*tempVelocity;
tempPosition=position+bVelocity*step/2;
tempVelocity=velocity+bAcceleration*step/2;

var cVelocity=tempVelocity;
var cAcceleration=this._tension*(
this._toValue-tempPosition)-this._friction*tempVelocity;
tempPosition=position+cVelocity*step/2;
tempVelocity=velocity+cAcceleration*step/2;

var dVelocity=tempVelocity;
var dAcceleration=this._tension*(
this._toValue-tempPosition)-this._friction*tempVelocity;
tempPosition=position+cVelocity*step/2;
tempVelocity=velocity+cAcceleration*step/2;

var dxdt=(aVelocity+2*(bVelocity+cVelocity)+dVelocity)/6;
var dvdt=(aAcceleration+2*(bAcceleration+cAcceleration)+dAcceleration)/6;

position+=dxdt*step;
velocity+=dvdt*step;
}

this._lastTime=now;
this._lastPosition=position;
this._lastVelocity=velocity;

this._onUpdate(position);
if(!this.__active){// a listener might have stopped us in _onUpdate
return;
}

// Conditions for stopping the spring animation
var isOvershooting=false;
if(this._overshootClamping&&this._tension!==0){
if(this._startPosition<this._toValue){
isOvershooting=position>this._toValue;
}else{
isOvershooting=position<this._toValue;
}
}
var isVelocity=Math.abs(velocity)<=this._restSpeedThreshold;
var isDisplacement=true;
if(this._tension!==0){
isDisplacement=Math.abs(this._toValue-position)<=this._restDisplacementThreshold;
}

if(isOvershooting||isVelocity&&isDisplacement){
if(this._tension!==0){
// Ensure that we end up with a round value
this._onUpdate(this._toValue);
}

this.__debouncedOnEnd({finished:true});
return;
}
this._animationFrame=requestAnimationFrame(this.onUpdate.bind(this));
}},{key:"stop",value:function stop()

{
babelHelpers.get(SpringAnimation.prototype.__proto__||Object.getPrototypeOf(SpringAnimation.prototype),"stop",this).call(this);
this.__active=false;
global.cancelAnimationFrame(this._animationFrame);
this.__debouncedOnEnd({finished:false});
}}]);return SpringAnimation;}(Animation);




var _uniqueId=1;

/**
 * Standard value for driving animations.  One `Animated.Value` can drive
 * multiple properties in a synchronized fashion, but can only be driven by one
 * mechanism at a time.  Using a new mechanism (e.g. starting a new animation,
 * or calling `setValue`) will stop any previous ones.
 */var
AnimatedValue=function(_AnimatedWithChildren){babelHelpers.inherits(AnimatedValue,_AnimatedWithChildren);








function AnimatedValue(value){babelHelpers.classCallCheck(this,AnimatedValue);var _this6=babelHelpers.possibleConstructorReturn(this,(AnimatedValue.__proto__||Object.getPrototypeOf(AnimatedValue)).call(this));

_this6._startingValue=_this6._value=value;
_this6._offset=0;
_this6._animation=null;
_this6._listeners={};return _this6;
}babelHelpers.createClass(AnimatedValue,[{key:"__detach",value:function __detach()

{
this.stopAnimation();
babelHelpers.get(AnimatedValue.prototype.__proto__||Object.getPrototypeOf(AnimatedValue.prototype),"__detach",this).call(this);
}},{key:"__getValue",value:function __getValue()

{
return this._value+this._offset;
}},{key:"__makeNative",value:function __makeNative()

{
babelHelpers.get(AnimatedValue.prototype.__proto__||Object.getPrototypeOf(AnimatedValue.prototype),"__makeNative",this).call(this);

if(Object.keys(this._listeners).length){
this._startListeningToNativeValueUpdates();
}
}

/**
   * Directly set the value.  This will stop any animations running on the value
   * and update all the bound properties.
   */},{key:"setValue",value:function setValue(
value){
if(this._animation){
this._animation.stop();
this._animation=null;
}
this._updateValue(
value,
!this.__isNative/* don't perform a flush for natively driven values */);
if(this.__isNative){
NativeAnimatedAPI.setAnimatedNodeValue(this.__getNativeTag(),value);
}
}

/**
   * Sets an offset that is applied on top of whatever value is set, whether via
   * `setValue`, an animation, or `Animated.event`.  Useful for compensating
   * things like the start of a pan gesture.
   */},{key:"setOffset",value:function setOffset(
offset){
this._offset=offset;
if(this.__isNative){
NativeAnimatedAPI.setAnimatedNodeOffset(this.__getNativeTag(),offset);
}
}

/**
   * Merges the offset value into the base value and resets the offset to zero.
   * The final output of the value is unchanged.
   */},{key:"flattenOffset",value:function flattenOffset()
{
this._value+=this._offset;
this._offset=0;
if(this.__isNative){
NativeAnimatedAPI.flattenAnimatedNodeOffset(this.__getNativeTag());
}
}

/**
   * Sets the offset value to the base value, and resets the base value to zero.
   * The final output of the value is unchanged.
   */},{key:"extractOffset",value:function extractOffset()
{
this._offset+=this._value;
this._value=0;
if(this.__isNative){
NativeAnimatedAPI.extractAnimatedNodeOffset(this.__getNativeTag());
}
}

/**
   * Adds an asynchronous listener to the value so you can observe updates from
   * animations.  This is useful because there is no way to
   * synchronously read the value because it might be driven natively.
   */},{key:"addListener",value:function addListener(
callback){
var id=String(_uniqueId++);
this._listeners[id]=callback;
if(this.__isNative){
this._startListeningToNativeValueUpdates();
}
return id;
}},{key:"removeListener",value:function removeListener(

id){
delete this._listeners[id];
if(this.__isNative&&Object.keys(this._listeners).length===0){
this._stopListeningForNativeValueUpdates();
}
}},{key:"removeAllListeners",value:function removeAllListeners()

{
this._listeners={};
if(this.__isNative){
this._stopListeningForNativeValueUpdates();
}
}},{key:"_startListeningToNativeValueUpdates",value:function _startListeningToNativeValueUpdates()

{var _this7=this;
if(this.__nativeAnimatedValueListener){
return;
}

NativeAnimatedAPI.startListeningToAnimatedNodeValue(this.__getNativeTag());
this.__nativeAnimatedValueListener=NativeAnimatedHelper.nativeEventEmitter.addListener(
'onAnimatedValueUpdate',
function(data){
if(data.tag!==_this7.__getNativeTag()){
return;
}
_this7._updateValue(data.value,false/* flush */);
});

}},{key:"_stopListeningForNativeValueUpdates",value:function _stopListeningForNativeValueUpdates()

{
if(!this.__nativeAnimatedValueListener){
return;
}

this.__nativeAnimatedValueListener.remove();
this.__nativeAnimatedValueListener=null;
NativeAnimatedAPI.stopListeningToAnimatedNodeValue(this.__getNativeTag());
}

/**
   * Stops any running animation or tracking.  `callback` is invoked with the
   * final value after stopping the animation, which is useful for updating
   * state to match the animation position with layout.
   */},{key:"stopAnimation",value:function stopAnimation(
callback){
this.stopTracking();
this._animation&&this._animation.stop();
this._animation=null;
callback&&callback(this.__getValue());
}

/**
  * Stops any animation and resets the value to its original
  */},{key:"resetAnimation",value:function resetAnimation(
callback){
this.stopAnimation(callback);
this._value=this._startingValue;
}

/**
   * Interpolates the value before updating the property, e.g. mapping 0-1 to
   * 0-10.
   */},{key:"interpolate",value:function interpolate(
config){
return new AnimatedInterpolation(this,config);
}

/**
   * Typically only used internally, but could be used by a custom Animation
   * class.
   */},{key:"animate",value:function animate(
animation,callback){var _this8=this;
var handle=null;
if(animation.__isInteraction){
handle=InteractionManager.createInteractionHandle();
}
var previousAnimation=this._animation;
this._animation&&this._animation.stop();
this._animation=animation;
animation.start(
this._value,
function(value){
// Natively driven animations will never call into that callback, therefore we can always
// pass flush = true to allow the updated value to propagate to native with setNativeProps
_this8._updateValue(value,true/* flush */);
},
function(result){
_this8._animation=null;
if(handle!==null){
InteractionManager.clearInteractionHandle(handle);
}
callback&&callback(result);
},
previousAnimation,
this);

}

/**
   * Typically only used internally.
   */},{key:"stopTracking",value:function stopTracking()
{
this._tracking&&this._tracking.__detach();
this._tracking=null;
}

/**
   * Typically only used internally.
   */},{key:"track",value:function track(
tracking){
this.stopTracking();
this._tracking=tracking;
}},{key:"_updateValue",value:function _updateValue(

value,flush){
this._value=value;
if(flush){
_flush(this);
}
for(var key in this._listeners){
this._listeners[key]({value:this.__getValue()});
}
}},{key:"__getNativeConfig",value:function __getNativeConfig()

{
return{
type:'value',
value:this._value,
offset:this._offset};

}}]);return AnimatedValue;}(AnimatedWithChildren);




/**
 * 2D Value for driving 2D animations, such as pan gestures.  Almost identical
 * API to normal `Animated.Value`, but multiplexed.  Contains two regular
 * `Animated.Value`s under the hood.
 *
 * #### Example
 *
 *```javascript
 *  class DraggableView extends React.Component {
 *    constructor(props) {
 *      super(props);
 *      this.state = {
 *        pan: new Animated.ValueXY(), // inits to zero
 *      };
 *      this.state.panResponder = PanResponder.create({
 *        onStartShouldSetPanResponder: () => true,
 *        onPanResponderMove: Animated.event([null, {
 *          dx: this.state.pan.x, // x,y are Animated.Value
 *          dy: this.state.pan.y,
 *        }]),
 *        onPanResponderRelease: () => {
 *          Animated.spring(
 *            this.state.pan,         // Auto-multiplexed
 *            {toValue: {x: 0, y: 0}} // Back to zero
 *          ).start();
 *        },
 *      });
 *    }
 *    render() {
 *      return (
 *        <Animated.View
 *          {...this.state.panResponder.panHandlers}
 *          style={this.state.pan.getLayout()}>
 *          {this.props.children}
 *        </Animated.View>
 *      );
 *    }
 *  }
 *```
 */var
AnimatedValueXY=function(_AnimatedWithChildren2){babelHelpers.inherits(AnimatedValueXY,_AnimatedWithChildren2);




function AnimatedValueXY(valueIn){babelHelpers.classCallCheck(this,AnimatedValueXY);var _this9=babelHelpers.possibleConstructorReturn(this,(AnimatedValueXY.__proto__||Object.getPrototypeOf(AnimatedValueXY)).call(this));

var value=valueIn||{x:0,y:0};// fixme: shouldn't need `: any`
if(typeof value.x==='number'&&typeof value.y==='number'){
_this9.x=new AnimatedValue(value.x);
_this9.y=new AnimatedValue(value.y);
}else{
invariant(
value.x instanceof AnimatedValue&&
value.y instanceof AnimatedValue,"AnimatedValueXY must be initalized with an object of numbers or AnimatedValues.");



_this9.x=value.x;
_this9.y=value.y;
}
_this9._listeners={};return _this9;
}babelHelpers.createClass(AnimatedValueXY,[{key:"setValue",value:function setValue(

value){
this.x.setValue(value.x);
this.y.setValue(value.y);
}},{key:"setOffset",value:function setOffset(

offset){
this.x.setOffset(offset.x);
this.y.setOffset(offset.y);
}},{key:"flattenOffset",value:function flattenOffset()

{
this.x.flattenOffset();
this.y.flattenOffset();
}},{key:"extractOffset",value:function extractOffset()

{
this.x.extractOffset();
this.y.extractOffset();
}},{key:"__getValue",value:function __getValue()

{
return{
x:this.x.__getValue(),
y:this.y.__getValue()};

}},{key:"resetAnimation",value:function resetAnimation(

callback){
this.x.resetAnimation();
this.y.resetAnimation();
callback&&callback(this.__getValue());
}},{key:"stopAnimation",value:function stopAnimation(

callback){
this.x.stopAnimation();
this.y.stopAnimation();
callback&&callback(this.__getValue());
}},{key:"addListener",value:function addListener(

callback){var _this10=this;
var id=String(_uniqueId++);
var jointCallback=function jointCallback(_ref2){var number=_ref2.value;
callback(_this10.__getValue());
};
this._listeners[id]={
x:this.x.addListener(jointCallback),
y:this.y.addListener(jointCallback)};

return id;
}},{key:"removeListener",value:function removeListener(

id){
this.x.removeListener(this._listeners[id].x);
this.y.removeListener(this._listeners[id].y);
delete this._listeners[id];
}},{key:"removeAllListeners",value:function removeAllListeners()

{
this.x.removeAllListeners();
this.y.removeAllListeners();
this._listeners={};
}

/**
   * Converts `{x, y}` into `{left, top}` for use in style, e.g.
   *
   *```javascript
   *  style={this.state.anim.getLayout()}
   *```
   */},{key:"getLayout",value:function getLayout()
{
return{
left:this.x,
top:this.y};

}

/**
   * Converts `{x, y}` into a useable translation transform, e.g.
   *
   *```javascript
   *  style={{
   *    transform: this.state.anim.getTranslateTransform()
   *  }}
   *```
   */},{key:"getTranslateTransform",value:function getTranslateTransform()
{
return[
{translateX:this.x},
{translateY:this.y}];

}}]);return AnimatedValueXY;}(AnimatedWithChildren);




/**
 * 3D Value for driving 3D animations.  Almost identical API to `Animated.ValueXY`.
 *
 * #### Example
 *
 *```javascript
 *  class Monster extends React.Component {
 *    constructor(props) {
 *      super(props);
 *      this.state = {
 *        position: new Animated.ValueVec3(), // inits to zero
 *      };
 *    }
 *    componentWillReceiveProps(nextProps) {
 *      if (nextProps.position) {
 *        Animated.timing(this.state.position, {
 *        duration: 1000,
 *        easing: Easing.inOut(Easing.quad),
 *        toValue: {x: position[0], y: position[1], z: position[2]});
 *      }
 *    }
 *    render() {
 *      return (
 *        <Animated.View
 *          style={{
 *            transform: [
 *              this.state.position.getTranslateTransform(),
 *              {scale: [0.5, 0.5, 0.5]},
 *            ]
 *          }}
 *          {this.props.children}
 *        </Animated.View>
 *      );
 *    }
 *  }
 *```
 */var
AnimatedValueVec3=function(_AnimatedWithChildren3){babelHelpers.inherits(AnimatedValueVec3,_AnimatedWithChildren3);






function AnimatedValueVec3(
valueIn)
{babelHelpers.classCallCheck(this,AnimatedValueVec3);var _this11=babelHelpers.possibleConstructorReturn(this,(AnimatedValueVec3.__proto__||Object.getPrototypeOf(AnimatedValueVec3)).call(this));

var value=valueIn||{x:0,y:0,z:0};// fixme: shouldn't need `: any`
if(typeof value.x==='number'&&typeof value.y==='number'&&typeof value.z==='number'){
_this11.x=new AnimatedValue(value.x);
_this11.y=new AnimatedValue(value.y);
_this11.z=new AnimatedValue(value.z);
}else{
invariant(
value.x instanceof AnimatedValue&&
value.y instanceof AnimatedValue&&
value.z instanceof AnimatedValue,
'AnimatedValueVec3 must be initalized with an object of numbers or AnimatedValues.');

_this11.x=value.x;
_this11.y=value.y;
_this11.z=value.z;
}
_this11._listeners={};return _this11;
}babelHelpers.createClass(AnimatedValueVec3,[{key:"setValue",value:function setValue(

value){
this.x.setValue(value.x);
this.y.setValue(value.y);
this.z.setValue(value.z);
}},{key:"setOffset",value:function setOffset(

offset){
this.x.setOffset(offset.x);
this.y.setOffset(offset.y);
this.z.setOffset(offset.z);
}},{key:"flattenOffset",value:function flattenOffset()

{
this.x.flattenOffset();
this.y.flattenOffset();
this.z.flattenOffset();
}},{key:"extractOffset",value:function extractOffset()

{
this.x.extractOffset();
this.y.extractOffset();
this.z.extractOffset();
}},{key:"__getValue",value:function __getValue()

{
return{
x:this.x.__getValue(),
y:this.y.__getValue(),
z:this.z.__getValue()};

}},{key:"resetAnimation",value:function resetAnimation(

callback){
this.x.resetAnimation();
this.y.resetAnimation();
this.z.resetAnimation();
callback&&callback(this.__getValue());
}},{key:"stopAnimation",value:function stopAnimation(

callback){
this.x.stopAnimation();
this.y.stopAnimation();
this.z.stopAnimation();
callback&&callback(this.__getValue());
}},{key:"addListener",value:function addListener(

callback){var _this12=this;
var id=String(_uniqueId++);
var sharedCallback=function sharedCallback(_ref3){var number=_ref3.value;
callback(_this12.__getValue());
};
this._listeners[id]={
x:this.x.addListener(sharedCallback),
y:this.y.addListener(sharedCallback),
z:this.z.addListener(sharedCallback)};

return id;
}},{key:"removeListener",value:function removeListener(

id){
this.x.removeListener(this._listeners[id].x);
this.y.removeListener(this._listeners[id].y);
this.z.removeListener(this._listeners[id].z);
delete this._listeners[id];
}},{key:"removeAllListeners",value:function removeAllListeners()

{
this.x.removeAllListeners();
this.y.removeAllListeners();
this.z.removeAllListeners();
this._listeners={};
}

/**
   * Converts `{x, y, z}` into a useable translation transform, e.g.
   *
   *```javascript
   *  style={{
   *    transform: [this.state.anim.getTranslateTransform()]
   *  }}
   *```
   */},{key:"getTranslateTransform",value:function getTranslateTransform()
{
return{translate:[this.x,this.y,this.z]};
}}]);return AnimatedValueVec3;}(AnimatedWithChildren);var


AnimatedInterpolation=function(_AnimatedWithChildren4){babelHelpers.inherits(AnimatedInterpolation,_AnimatedWithChildren4);




function AnimatedInterpolation(parent,config){babelHelpers.classCallCheck(this,AnimatedInterpolation);var _this13=babelHelpers.possibleConstructorReturn(this,(AnimatedInterpolation.__proto__||Object.getPrototypeOf(AnimatedInterpolation)).call(this));

_this13._parent=parent;
_this13._config=config;
_this13._interpolation=Interpolation.create(config);return _this13;
}babelHelpers.createClass(AnimatedInterpolation,[{key:"__getValue",value:function __getValue()

{
var parentValue=this._parent.__getValue();
invariant(
typeof parentValue==='number',
'Cannot interpolate an input which is not a number.');

return this._interpolation(parentValue);
}},{key:"interpolate",value:function interpolate(

config){
return new AnimatedInterpolation(this,config);
}},{key:"__attach",value:function __attach()

{
this._parent.__addChild(this);
}},{key:"__detach",value:function __detach()

{
this._parent.__removeChild(this);
babelHelpers.get(AnimatedInterpolation.prototype.__proto__||Object.getPrototypeOf(AnimatedInterpolation.prototype),"__detach",this).call(this);
}},{key:"__transformDataType",value:function __transformDataType(

range){
// Change the string array type to number array
// So we can reuse the same logic in iOS and Android platform
return range.map(function(value){
if(typeof value!=='string'){
return value;
}
if(/deg$/.test(value)){
var degrees=parseFloat(value)||0;
var radians=degrees*Math.PI/180.0;
return radians;
}else{
// Assume radians
return parseFloat(value)||0;
}
});
}},{key:"__getNativeConfig",value:function __getNativeConfig()

{




return{
inputRange:this._config.inputRange,
// Only the `outputRange` can contain strings so we don't need to tranform `inputRange` here
outputRange:this.__transformDataType(this._config.outputRange),
extrapolateLeft:this._config.extrapolateLeft||this._config.extrapolate||'extend',
extrapolateRight:this._config.extrapolateRight||this._config.extrapolate||'extend',
type:'interpolation'};

}}]);return AnimatedInterpolation;}(AnimatedWithChildren);var


AnimatedAddition=function(_AnimatedWithChildren5){babelHelpers.inherits(AnimatedAddition,_AnimatedWithChildren5);



function AnimatedAddition(a,b){babelHelpers.classCallCheck(this,AnimatedAddition);var _this14=babelHelpers.possibleConstructorReturn(this,(AnimatedAddition.__proto__||Object.getPrototypeOf(AnimatedAddition)).call(this));

_this14._a=typeof a==='number'?new AnimatedValue(a):a;
_this14._b=typeof b==='number'?new AnimatedValue(b):b;return _this14;
}babelHelpers.createClass(AnimatedAddition,[{key:"__makeNative",value:function __makeNative()

{
this._a.__makeNative();
this._b.__makeNative();
babelHelpers.get(AnimatedAddition.prototype.__proto__||Object.getPrototypeOf(AnimatedAddition.prototype),"__makeNative",this).call(this);
}},{key:"__getValue",value:function __getValue()

{
return this._a.__getValue()+this._b.__getValue();
}},{key:"interpolate",value:function interpolate(

config){
return new AnimatedInterpolation(this,config);
}},{key:"__attach",value:function __attach()

{
this._a.__addChild(this);
this._b.__addChild(this);
}},{key:"__detach",value:function __detach()

{
this._a.__removeChild(this);
this._b.__removeChild(this);
babelHelpers.get(AnimatedAddition.prototype.__proto__||Object.getPrototypeOf(AnimatedAddition.prototype),"__detach",this).call(this);
}},{key:"__getNativeConfig",value:function __getNativeConfig()

{
return{
type:'addition',
input:[this._a.__getNativeTag(),this._b.__getNativeTag()]};

}}]);return AnimatedAddition;}(AnimatedWithChildren);var


AnimatedDivision=function(_AnimatedWithChildren6){babelHelpers.inherits(AnimatedDivision,_AnimatedWithChildren6);



function AnimatedDivision(a,b){babelHelpers.classCallCheck(this,AnimatedDivision);var _this15=babelHelpers.possibleConstructorReturn(this,(AnimatedDivision.__proto__||Object.getPrototypeOf(AnimatedDivision)).call(this));

_this15._a=typeof a==='number'?new AnimatedValue(a):a;
_this15._b=typeof b==='number'?new AnimatedValue(b):b;return _this15;
}babelHelpers.createClass(AnimatedDivision,[{key:"__makeNative",value:function __makeNative()

{
babelHelpers.get(AnimatedDivision.prototype.__proto__||Object.getPrototypeOf(AnimatedDivision.prototype),"__makeNative",this).call(this);
this._a.__makeNative();
this._b.__makeNative();
}},{key:"__getValue",value:function __getValue()

{
var a=this._a.__getValue();
var b=this._b.__getValue();
if(b===0){
console.error('Detected division by zero in AnimatedDivision');
}
return a/b;
}},{key:"interpolate",value:function interpolate(

config){
return new AnimatedInterpolation(this,config);
}},{key:"__attach",value:function __attach()

{
this._a.__addChild(this);
this._b.__addChild(this);
}},{key:"__detach",value:function __detach()

{
this._a.__removeChild(this);
this._b.__removeChild(this);
babelHelpers.get(AnimatedDivision.prototype.__proto__||Object.getPrototypeOf(AnimatedDivision.prototype),"__detach",this).call(this);
}},{key:"__getNativeConfig",value:function __getNativeConfig()

{
return{
type:'division',
input:[this._a.__getNativeTag(),this._b.__getNativeTag()]};

}}]);return AnimatedDivision;}(AnimatedWithChildren);var


AnimatedMultiplication=function(_AnimatedWithChildren7){babelHelpers.inherits(AnimatedMultiplication,_AnimatedWithChildren7);



function AnimatedMultiplication(a,b){babelHelpers.classCallCheck(this,AnimatedMultiplication);var _this16=babelHelpers.possibleConstructorReturn(this,(AnimatedMultiplication.__proto__||Object.getPrototypeOf(AnimatedMultiplication)).call(this));

_this16._a=typeof a==='number'?new AnimatedValue(a):a;
_this16._b=typeof b==='number'?new AnimatedValue(b):b;return _this16;
}babelHelpers.createClass(AnimatedMultiplication,[{key:"__makeNative",value:function __makeNative()

{
babelHelpers.get(AnimatedMultiplication.prototype.__proto__||Object.getPrototypeOf(AnimatedMultiplication.prototype),"__makeNative",this).call(this);
this._a.__makeNative();
this._b.__makeNative();
}},{key:"__getValue",value:function __getValue()

{
return this._a.__getValue()*this._b.__getValue();
}},{key:"interpolate",value:function interpolate(

config){
return new AnimatedInterpolation(this,config);
}},{key:"__attach",value:function __attach()

{
this._a.__addChild(this);
this._b.__addChild(this);
}},{key:"__detach",value:function __detach()

{
this._a.__removeChild(this);
this._b.__removeChild(this);
babelHelpers.get(AnimatedMultiplication.prototype.__proto__||Object.getPrototypeOf(AnimatedMultiplication.prototype),"__detach",this).call(this);
}},{key:"__getNativeConfig",value:function __getNativeConfig()

{
return{
type:'multiplication',
input:[this._a.__getNativeTag(),this._b.__getNativeTag()]};

}}]);return AnimatedMultiplication;}(AnimatedWithChildren);var


AnimatedModulo=function(_AnimatedWithChildren8){babelHelpers.inherits(AnimatedModulo,_AnimatedWithChildren8);



function AnimatedModulo(a,modulus){babelHelpers.classCallCheck(this,AnimatedModulo);var _this17=babelHelpers.possibleConstructorReturn(this,(AnimatedModulo.__proto__||Object.getPrototypeOf(AnimatedModulo)).call(this));

_this17._a=a;
_this17._modulus=modulus;return _this17;
}babelHelpers.createClass(AnimatedModulo,[{key:"__makeNative",value:function __makeNative()

{
babelHelpers.get(AnimatedModulo.prototype.__proto__||Object.getPrototypeOf(AnimatedModulo.prototype),"__makeNative",this).call(this);
this._a.__makeNative();
}},{key:"__getValue",value:function __getValue()

{
return(this._a.__getValue()%this._modulus+this._modulus)%this._modulus;
}},{key:"interpolate",value:function interpolate(

config){
return new AnimatedInterpolation(this,config);
}},{key:"__attach",value:function __attach()

{
this._a.__addChild(this);
}},{key:"__detach",value:function __detach()

{
this._a.__removeChild(this);
babelHelpers.get(AnimatedModulo.prototype.__proto__||Object.getPrototypeOf(AnimatedModulo.prototype),"__detach",this).call(this);
}},{key:"__getNativeConfig",value:function __getNativeConfig()

{
return{
type:'modulus',
input:this._a.__getNativeTag(),
modulus:this._modulus};

}}]);return AnimatedModulo;}(AnimatedWithChildren);var


AnimatedDiffClamp=function(_AnimatedWithChildren9){babelHelpers.inherits(AnimatedDiffClamp,_AnimatedWithChildren9);






function AnimatedDiffClamp(a,min,max){babelHelpers.classCallCheck(this,AnimatedDiffClamp);var _this18=babelHelpers.possibleConstructorReturn(this,(AnimatedDiffClamp.__proto__||Object.getPrototypeOf(AnimatedDiffClamp)).call(this));


_this18._a=a;
_this18._min=min;
_this18._max=max;
_this18._value=_this18._lastValue=_this18._a.__getValue();return _this18;
}babelHelpers.createClass(AnimatedDiffClamp,[{key:"__makeNative",value:function __makeNative()

{
babelHelpers.get(AnimatedDiffClamp.prototype.__proto__||Object.getPrototypeOf(AnimatedDiffClamp.prototype),"__makeNative",this).call(this);
this._a.__makeNative();
}},{key:"interpolate",value:function interpolate(

config){
return new AnimatedInterpolation(this,config);
}},{key:"__getValue",value:function __getValue()

{
var value=this._a.__getValue();
var diff=value-this._lastValue;
this._lastValue=value;
this._value=Math.min(Math.max(this._value+diff,this._min),this._max);
return this._value;
}},{key:"__attach",value:function __attach()

{
this._a.__addChild(this);
}},{key:"__detach",value:function __detach()

{
this._a.__removeChild(this);
babelHelpers.get(AnimatedDiffClamp.prototype.__proto__||Object.getPrototypeOf(AnimatedDiffClamp.prototype),"__detach",this).call(this);
}},{key:"__getNativeConfig",value:function __getNativeConfig()

{
return{
type:'diffclamp',
input:this._a.__getNativeTag(),
min:this._min,
max:this._max};

}}]);return AnimatedDiffClamp;}(AnimatedWithChildren);var


AnimatedTransform=function(_AnimatedWithChildren10){babelHelpers.inherits(AnimatedTransform,_AnimatedWithChildren10);


function AnimatedTransform(transforms){babelHelpers.classCallCheck(this,AnimatedTransform);var _this19=babelHelpers.possibleConstructorReturn(this,(AnimatedTransform.__proto__||Object.getPrototypeOf(AnimatedTransform)).call(this));

_this19._transforms=transforms;return _this19;
}babelHelpers.createClass(AnimatedTransform,[{key:"__makeNative",value:function __makeNative()

{
babelHelpers.get(AnimatedTransform.prototype.__proto__||Object.getPrototypeOf(AnimatedTransform.prototype),"__makeNative",this).call(this);
this._transforms.forEach(function(transform){
for(var key in transform){
var value=transform[key];
if(value instanceof Animated){
value.__makeNative();
}
}
});
}},{key:"__getValue",value:function __getValue()

{
return this._transforms.map(function(transform){
var result={};
for(var key in transform){
var value=transform[key];
if(value instanceof Animated){
result[key]=value.__getValue();
}else if(Array.isArray(value)){
// For VR we have transform properties like translate, scale, etc. which are vectors
// So we're going to look 1-level deep
result[key]=[];
for(var i=0;i<value.length;++i){
if(value[i]instanceof Animated){
result[key][i]=value[i].__getValue();
}else{
result[key][i]=value[i];
}
}
}else{
result[key]=value;
}
}
return result;
});
}},{key:"__getAnimatedValue",value:function __getAnimatedValue()

{
return this._transforms.map(function(transform){
var result={};
for(var key in transform){
var value=transform[key];
if(value instanceof Animated){
result[key]=value.__getAnimatedValue();
}else if(Array.isArray(value)){
// For VR we have transform properties like translate, scale, etc. which are vectors
// So we're going to look 1-level deep
result[key]=[];
for(var i=0;i<value.length;++i){
if(value[i]instanceof Animated){
result[key][i]=value[i].__getAnimatedValue();
}else{
result[key][i]=value[i];
}
}
}else{
// All transform components needed to recompose matrix
result[key]=value;
}
}
return result;
});
}},{key:"__attach",value:function __attach()

{var _this20=this;
this._transforms.forEach(function(transform){
for(var key in transform){
var value=transform[key];
if(value instanceof Animated){
value.__addChild(_this20);
}
}
});
}},{key:"__detach",value:function __detach()

{var _this21=this;
this._transforms.forEach(function(transform){
for(var key in transform){
var value=transform[key];
if(value instanceof Animated){
value.__removeChild(_this21);
}
}
});
babelHelpers.get(AnimatedTransform.prototype.__proto__||Object.getPrototypeOf(AnimatedTransform.prototype),"__detach",this).call(this);
}},{key:"__getNativeConfig",value:function __getNativeConfig()

{
var transConfigs=[];

this._transforms.forEach(function(transform){
for(var key in transform){
var value=transform[key];
if(value instanceof Animated){
transConfigs.push({
type:'animated',
property:key,
nodeTag:value.__getNativeTag()});

}else{
transConfigs.push({
type:'static',
property:key,
value:value});

}
}
});

NativeAnimatedHelper.validateTransform(transConfigs);
return{
type:'transform',
transforms:transConfigs};

}}]);return AnimatedTransform;}(AnimatedWithChildren);var


AnimatedStyle=function(_AnimatedWithChildren11){babelHelpers.inherits(AnimatedStyle,_AnimatedWithChildren11);


function AnimatedStyle(style){babelHelpers.classCallCheck(this,AnimatedStyle);var _this22=babelHelpers.possibleConstructorReturn(this,(AnimatedStyle.__proto__||Object.getPrototypeOf(AnimatedStyle)).call(this));

style=flattenStyle(style)||{};
if(style.transform){
style=babelHelpers.extends({},
style,{
transform:new AnimatedTransform(style.transform)});

}
_this22._style=style;return _this22;
}

// Recursively get values for nested styles (like iOS's shadowOffset)
babelHelpers.createClass(AnimatedStyle,[{key:"__walkStyleAndGetValues",value:function __walkStyleAndGetValues(style){
var updatedStyle={};
for(var _key in style){
var _value=style[_key];
if(_value instanceof Animated){
if(!_value.__isNative){
// We cannot use value of natively driven nodes this way as the value we have access from
// JS may not be up to date.
updatedStyle[_key]=_value.__getValue();
}
}else if(_value&&!Array.isArray(_value)&&typeof _value==='object'){
// Support animating nested values (for example: shadowOffset.height)
updatedStyle[_key]=this.__walkStyleAndGetValues(_value);
}else{
updatedStyle[_key]=_value;
}
}
return updatedStyle;
}},{key:"__getValue",value:function __getValue()

{
return this.__walkStyleAndGetValues(this._style);
}

// Recursively get animated values for nested styles (like iOS's shadowOffset)
},{key:"__walkStyleAndGetAnimatedValues",value:function __walkStyleAndGetAnimatedValues(style){
var updatedStyle={};
for(var _key2 in style){
var _value2=style[_key2];
if(_value2 instanceof Animated){
updatedStyle[_key2]=_value2.__getAnimatedValue();
}else if(_value2&&!Array.isArray(_value2)&&typeof _value2==='object'){
// Support animating nested values (for example: shadowOffset.height)
updatedStyle[_key2]=this.__walkStyleAndGetAnimatedValues(_value2);
}
}
return updatedStyle;
}},{key:"__getAnimatedValue",value:function __getAnimatedValue()

{
return this.__walkStyleAndGetAnimatedValues(this._style);
}},{key:"__attach",value:function __attach()

{
for(var key in this._style){
var value=this._style[key];
if(value instanceof Animated){
value.__addChild(this);
}
}
}},{key:"__detach",value:function __detach()

{
for(var key in this._style){
var value=this._style[key];
if(value instanceof Animated){
value.__removeChild(this);
}
}
babelHelpers.get(AnimatedStyle.prototype.__proto__||Object.getPrototypeOf(AnimatedStyle.prototype),"__detach",this).call(this);
}},{key:"__makeNative",value:function __makeNative()

{
babelHelpers.get(AnimatedStyle.prototype.__proto__||Object.getPrototypeOf(AnimatedStyle.prototype),"__makeNative",this).call(this);
for(var key in this._style){
var value=this._style[key];
if(value instanceof Animated){
value.__makeNative();
}
}
}},{key:"__getNativeConfig",value:function __getNativeConfig()

{
var styleConfig={};
for(var styleKey in this._style){
if(this._style[styleKey]instanceof Animated){
styleConfig[styleKey]=this._style[styleKey].__getNativeTag();
}
// Non-animated styles are set using `setNativeProps`, no need
// to pass those as a part of the node config
}
NativeAnimatedHelper.validateStyles(styleConfig);
return{
type:'style',
style:styleConfig};

}}]);return AnimatedStyle;}(AnimatedWithChildren);var


AnimatedProps=function(_Animated2){babelHelpers.inherits(AnimatedProps,_Animated2);




function AnimatedProps(
props,
callback)
{babelHelpers.classCallCheck(this,AnimatedProps);var _this23=babelHelpers.possibleConstructorReturn(this,(AnimatedProps.__proto__||Object.getPrototypeOf(AnimatedProps)).call(this));

if(props.style){
props=babelHelpers.extends({},
props,{
style:new AnimatedStyle(props.style)});

}
_this23._props=props;
_this23._callback=callback;
_this23.__attach();return _this23;
}babelHelpers.createClass(AnimatedProps,[{key:"__getValue",value:function __getValue()

{
var props={};
for(var key in this._props){
var value=this._props[key];
if(value instanceof Animated){
if(!value.__isNative||value instanceof AnimatedStyle){
// We cannot use value of natively driven nodes this way as the value we have access from
// JS may not be up to date.
props[key]=value.__getValue();
}
}else if(value instanceof AnimatedEvent){
props[key]=value.__getHandler();
}else{
props[key]=value;
}
}
return props;
}},{key:"__getAnimatedValue",value:function __getAnimatedValue()

{
var props={};
for(var key in this._props){
var value=this._props[key];
if(value instanceof Animated){
props[key]=value.__getAnimatedValue();
}
}
return props;
}},{key:"__attach",value:function __attach()

{
for(var key in this._props){
var value=this._props[key];
if(value instanceof Animated){
value.__addChild(this);
}
}
}},{key:"__detach",value:function __detach()

{
if(this.__isNative&&this._animatedView){
this.__disconnectAnimatedView();
}
for(var key in this._props){
var value=this._props[key];
if(value instanceof Animated){
value.__removeChild(this);
}
}
babelHelpers.get(AnimatedProps.prototype.__proto__||Object.getPrototypeOf(AnimatedProps.prototype),"__detach",this).call(this);
}},{key:"update",value:function update()

{
this._callback();
}},{key:"__makeNative",value:function __makeNative()

{
if(!this.__isNative){
this.__isNative=true;
for(var key in this._props){
var value=this._props[key];
if(value instanceof Animated){
value.__makeNative();
}
}
if(this._animatedView){
this.__connectAnimatedView();
}
}
}},{key:"setNativeView",value:function setNativeView(

animatedView){
if(this._animatedView===animatedView){
return;
}
this._animatedView=animatedView;
if(this.__isNative){
this.__connectAnimatedView();
}
}},{key:"__connectAnimatedView",value:function __connectAnimatedView()

{
invariant(this.__isNative,'Expected node to be marked as "native"');
var nativeViewTag=ReactNative.findNodeHandle(this._animatedView);
invariant(nativeViewTag!=null,'Unable to locate attached view in the native tree');
NativeAnimatedAPI.connectAnimatedNodeToView(this.__getNativeTag(),nativeViewTag);
}},{key:"__disconnectAnimatedView",value:function __disconnectAnimatedView()

{
invariant(this.__isNative,'Expected node to be marked as "native"');
var nativeViewTag=ReactNative.findNodeHandle(this._animatedView);
invariant(nativeViewTag!=null,'Unable to locate attached view in the native tree');
NativeAnimatedAPI.disconnectAnimatedNodeFromView(this.__getNativeTag(),nativeViewTag);
}},{key:"__getNativeConfig",value:function __getNativeConfig()

{
var propsConfig={};
for(var propKey in this._props){
var value=this._props[propKey];
if(value instanceof Animated){
propsConfig[propKey]=value.__getNativeTag();
}
}
return{
type:'props',
props:propsConfig};

}}]);return AnimatedProps;}(Animated);


function createAnimatedComponent(Component){var
AnimatedComponent=function(_React$Component){babelHelpers.inherits(AnimatedComponent,_React$Component);






function AnimatedComponent(props){babelHelpers.classCallCheck(this,AnimatedComponent);var _this24=babelHelpers.possibleConstructorReturn(this,(AnimatedComponent.__proto__||Object.getPrototypeOf(AnimatedComponent)).call(this,
props));_this24._eventDetachers=[];
_this24._setComponentRef=_this24._setComponentRef.bind(_this24);return _this24;
}babelHelpers.createClass(AnimatedComponent,[{key:"componentWillUnmount",value:function componentWillUnmount()

{
this._propsAnimated&&this._propsAnimated.__detach();
this._detachNativeEvents();
}},{key:"setNativeProps",value:function setNativeProps(

props){
this._component.setNativeProps(props);
}},{key:"componentWillMount",value:function componentWillMount()

{
this._attachProps(this.props);
}},{key:"componentDidMount",value:function componentDidMount()

{
this._propsAnimated.setNativeView(this._component);
this._attachNativeEvents();
}},{key:"_attachNativeEvents",value:function _attachNativeEvents()

{var _this25=this;
// Make sure to get the scrollable node for components that implement
// `ScrollResponder.Mixin`.
var scrollableNode=this._component.getScrollableNode?
this._component.getScrollableNode():
this._component;var _loop=function _loop(

_key3){
var prop=_this25.props[_key3];
if(prop instanceof AnimatedEvent&&prop.__isNative){
prop.__attach(scrollableNode,_key3);
_this25._eventDetachers.push(function(){return prop.__detach(scrollableNode,_key3);});
}};for(var _key3 in this.props){_loop(_key3);
}
}},{key:"_detachNativeEvents",value:function _detachNativeEvents()

{
this._eventDetachers.forEach(function(remove){return remove();});
this._eventDetachers=[];
}},{key:"_attachProps",value:function _attachProps(

nextProps){var _this26=this;
var oldPropsAnimated=this._propsAnimated;

// The system is best designed when setNativeProps is implemented. It is
// able to avoid re-rendering and directly set the attributes that
// changed. However, setNativeProps can only be implemented on leaf
// native components. If you want to animate a composite component, you
// need to re-render it. In this case, we have a fallback that uses
// forceUpdate.
var callback=function callback(){
if(_this26._component.setNativeProps){
if(!_this26._propsAnimated.__isNative){
_this26._component.setNativeProps(
_this26._propsAnimated.__getAnimatedValue());

}else{
throw new Error("Attempting to run JS driven animation on animated node that has been moved to \"native\" earlier by starting an animation with `useNativeDriver: true`");


}
}else{
_this26.forceUpdate();
}
};

this._propsAnimated=new AnimatedProps(
nextProps,
callback);


// When you call detach, it removes the element from the parent list
// of children. If it goes to 0, then the parent also detaches itself
// and so on.
// An optimization is to attach the new elements and THEN detach the old
// ones instead of detaching and THEN attaching.
// This way the intermediate state isn't to go to 0 and trigger
// this expensive recursive detaching to then re-attach everything on
// the very next operation.
oldPropsAnimated&&oldPropsAnimated.__detach();
}},{key:"componentWillReceiveProps",value:function componentWillReceiveProps(

newProps){
this._attachProps(newProps);
}},{key:"componentDidUpdate",value:function componentDidUpdate(

prevProps){
if(this._component!==this._prevComponent){
this._propsAnimated.setNativeView(this._component);
}
if(this._component!==this._prevComponent||prevProps!==this.props){
this._detachNativeEvents();
this._attachNativeEvents();
}
}},{key:"render",value:function render()

{
return(
React.createElement(Component,babelHelpers.extends({},
this._propsAnimated.__getValue(),{
ref:this._setComponentRef})));


}},{key:"_setComponentRef",value:function _setComponentRef(

c){
this._prevComponent=this._component;
this._component=c;
}

// A third party library can use getNode()
// to get the node reference of the decorated component
},{key:"getNode",value:function getNode(){
return this._component;
}}]);return AnimatedComponent;}(React.Component);


// ReactNative `View.propTypes` have been deprecated in favor of
// `ViewPropTypes`. In their place a temporary getter has been added with a
// deprecated warning message. Avoid triggering that warning here by using
// temporary workaround, __propTypesSecretDontUseThesePlease.
// TODO (bvaughn) Revert this particular change any time after April 1
var propTypes=
Component.__propTypesSecretDontUseThesePlease||
Component.propTypes;

AnimatedComponent.propTypes={
style:function style(props,propName,componentName){
if(!propTypes){
return;
}

for(var key in ViewStylePropTypes){
if(!propTypes[key]&&props[key]!==undefined){
console.warn(
'You are setting the style `{ '+key+': ... }` as a prop. You '+
'should nest it in a style object. '+
'E.g. `{ style: { '+key+': ... } }`');

}
}
}};


return AnimatedComponent;
}var

AnimatedTracking=function(_Animated3){babelHelpers.inherits(AnimatedTracking,_Animated3);






function AnimatedTracking(
value,
parent,
animationClass,
animationConfig,
callback)
{babelHelpers.classCallCheck(this,AnimatedTracking);var _this27=babelHelpers.possibleConstructorReturn(this,(AnimatedTracking.__proto__||Object.getPrototypeOf(AnimatedTracking)).call(this));

_this27._value=value;
_this27._parent=parent;
_this27._animationClass=animationClass;
_this27._animationConfig=animationConfig;
_this27._callback=callback;
_this27.__attach();return _this27;
}babelHelpers.createClass(AnimatedTracking,[{key:"__getValue",value:function __getValue()

{
return this._parent.__getValue();
}},{key:"__attach",value:function __attach()

{
this._parent.__addChild(this);
}},{key:"__detach",value:function __detach()

{
this._parent.__removeChild(this);
babelHelpers.get(AnimatedTracking.prototype.__proto__||Object.getPrototypeOf(AnimatedTracking.prototype),"__detach",this).call(this);
}},{key:"update",value:function update()

{
this._value.animate(new this._animationClass(babelHelpers.extends({},
this._animationConfig,{
toValue:this._animationConfig.toValue.__getValue()})),
this._callback);
}}]);return AnimatedTracking;}(Animated);










var add=function add(
a,
b)
{
return new AnimatedAddition(a,b);
};

var divide=function divide(
a,
b)
{
return new AnimatedDivision(a,b);
};

var multiply=function multiply(
a,
b)
{
return new AnimatedMultiplication(a,b);
};

var modulo=function modulo(
a,
modulus)
{
return new AnimatedModulo(a,modulus);
};

var diffClamp=function diffClamp(
a,
min,
max)
{
return new AnimatedDiffClamp(a,min,max);
};

var _combineCallbacks=function _combineCallbacks(callback,config){
if(callback&&config.onComplete){
return function(){
config.onComplete&&config.onComplete.apply(config,arguments);
callback&&callback.apply(undefined,arguments);
};
}else{
return callback||config.onComplete;
}
};

var maybeVectorAnim=function maybeVectorAnim(
value,
config,
anim)
{
if(value instanceof AnimatedValueXY){
var configX=babelHelpers.extends({},config);
var configY=babelHelpers.extends({},config);
for(var key in config){var _config$key=
config[key],x=_config$key.x,y=_config$key.y;
if(x!==undefined&&y!==undefined){
configX[key]=x;
configY[key]=y;
}
}
var aX=anim(value.x,configX);
var aY=anim(value.y,configY);
// We use `stopTogether: false` here because otherwise tracking will break
// because the second animation will get stopped before it can update.
return parallel([aX,aY],{stopTogether:false});
}else if(value instanceof AnimatedValueVec3){
var _configX=babelHelpers.extends({},config);
var _configY=babelHelpers.extends({},config);
var configZ=babelHelpers.extends({},config);
for(var _key4 in config){var _config$_key=
config[_key4],_x=_config$_key.x,_y=_config$_key.y,_z=_config$_key.z;
if(_x!==undefined&&_y!==undefined&&_z!==undefined){
_configX[_key4]=_x;
_configY[_key4]=_y;
configZ[_key4]=_z;
}
}
var _aX=anim(value.x,_configX);
var _aY=anim(value.y,_configY);
var aZ=anim(value.z,configZ);
// We use `stopTogether: false` here because otherwise tracking will break
// because the second animation will get stopped before it can update.
return parallel([_aX,_aY,aZ],{stopTogether:false});
}
return null;
};

var spring=function spring(
value,
config)
{
var start=function start(
animatedValue,
configuration,
callback){
callback=_combineCallbacks(callback,configuration);
var singleValue=animatedValue;
var singleConfig=configuration;
singleValue.stopTracking();
if(configuration.toValue instanceof Animated){
singleValue.track(new AnimatedTracking(
singleValue,
configuration.toValue,
SpringAnimation,
singleConfig,
callback));

}else{
singleValue.animate(new SpringAnimation(singleConfig),callback);
}
};
return maybeVectorAnim(value,config,spring)||{
start:function(_start){function start(_x2){return _start.apply(this,arguments);}start.toString=function(){return _start.toString();};return start;}(function(callback){
start(value,config,callback);
}),

stop:function stop(){
value.stopAnimation();
},

reset:function reset(){
value.resetAnimation();
},

_startNativeLoop:function _startNativeLoop(iterations){
var singleConfig=babelHelpers.extends({},config,{iterations:iterations});
start(value,singleConfig);
},

_isUsingNativeDriver:function _isUsingNativeDriver(){
return config.useNativeDriver||false;
}};

};

var timing=function timing(
value,
config)
{
var start=function start(
animatedValue,
configuration,
callback){
callback=_combineCallbacks(callback,configuration);
var singleValue=animatedValue;
var singleConfig=configuration;
singleValue.stopTracking();
if(configuration.toValue instanceof Animated){
singleValue.track(new AnimatedTracking(
singleValue,
configuration.toValue,
TimingAnimation,
singleConfig,
callback));

}else{
singleValue.animate(new TimingAnimation(singleConfig),callback);
}
};

return maybeVectorAnim(value,config,timing)||{
start:function(_start2){function start(_x3){return _start2.apply(this,arguments);}start.toString=function(){return _start2.toString();};return start;}(function(callback){
start(value,config,callback);
}),

stop:function stop(){
value.stopAnimation();
},

reset:function reset(){
value.resetAnimation();
},

_startNativeLoop:function _startNativeLoop(iterations){
var singleConfig=babelHelpers.extends({},config,{iterations:iterations});
start(value,singleConfig);
},

_isUsingNativeDriver:function _isUsingNativeDriver(){
return config.useNativeDriver||false;
}};

};

var decay=function decay(
value,
config)
{
var start=function start(
animatedValue,
configuration,
callback){
callback=_combineCallbacks(callback,configuration);
var singleValue=animatedValue;
var singleConfig=configuration;
singleValue.stopTracking();
singleValue.animate(new DecayAnimation(singleConfig),callback);
};

return maybeVectorAnim(value,config,decay)||{
start:function(_start3){function start(_x4){return _start3.apply(this,arguments);}start.toString=function(){return _start3.toString();};return start;}(function(callback){
start(value,config,callback);
}),

stop:function stop(){
value.stopAnimation();
},

reset:function reset(){
value.resetAnimation();
},

_startNativeLoop:function _startNativeLoop(iterations){
var singleConfig=babelHelpers.extends({},config,{iterations:iterations});
start(value,singleConfig);
},

_isUsingNativeDriver:function _isUsingNativeDriver(){
return config.useNativeDriver||false;
}};

};

var sequence=function sequence(
animations)
{
var current=0;
return{
start:function start(callback){
var onComplete=function onComplete(result){
if(!result.finished){
callback&&callback(result);
return;
}

current++;

if(current===animations.length){
callback&&callback(result);
return;
}

animations[current].start(onComplete);
};

if(animations.length===0){
callback&&callback({finished:true});
}else{
animations[current].start(onComplete);
}
},

stop:function stop(){
if(current<animations.length){
animations[current].stop();
}
},

reset:function reset(){
animations.forEach(function(animation,idx){
if(idx<=current){
animation.reset();
}
});
current=0;
},

_startNativeLoop:function _startNativeLoop(){
throw new Error('Loops run using the native driver cannot contain Animated.sequence animations');
},

_isUsingNativeDriver:function _isUsingNativeDriver(){
return false;
}};

};




var parallel=function parallel(
animations,
config)
{
var doneCount=0;
// Make sure we only call stop() at most once for each animation
var hasEnded={};
var stopTogether=!(config&&config.stopTogether===false);

var result={
start:function start(callback){
if(doneCount===animations.length){
callback&&callback({finished:true});
return;
}

animations.forEach(function(animation,idx){
var cb=function cb(endResult){
hasEnded[idx]=true;
doneCount++;
if(doneCount===animations.length){
doneCount=0;
callback&&callback(endResult);
return;
}

if(!endResult.finished&&stopTogether){
result.stop();
}
};

if(!animation){
cb({finished:true});
}else{
animation.start(cb);
}
});
},

stop:function stop(){
animations.forEach(function(animation,idx){
!hasEnded[idx]&&animation.stop();
hasEnded[idx]=true;
});
},

reset:function reset(){
animations.forEach(function(animation,idx){
animation.reset();
hasEnded[idx]=false;
doneCount=0;
});
},

_startNativeLoop:function _startNativeLoop(){
throw new Error('Loops run using the native driver cannot contain Animated.parallel animations');
},

_isUsingNativeDriver:function _isUsingNativeDriver(){
return false;
}};


return result;
};

var delay=function delay(time){
// Would be nice to make a specialized implementation
return timing(new AnimatedValue(0),{toValue:0,delay:time,duration:0});
};

var stagger=function stagger(
time,
animations)
{
return parallel(animations.map(function(animation,i){
return sequence([
delay(time*i),
animation]);

}));
};



var loop=function loop(
animation)

{var _ref4=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{},_ref4$iterations=_ref4.iterations,iterations=_ref4$iterations===undefined?-1:_ref4$iterations;
var isFinished=false;
var iterationsSoFar=0;
return{
start:function start(callback){
var restart=function restart(){var result=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{finished:true};
if(isFinished||
iterationsSoFar===iterations||
result.finished===false){
callback&&callback(result);
}else{
iterationsSoFar++;
animation.reset();
animation.start(restart);
}
};
if(!animation||iterations===0){
callback&&callback({finished:true});
}else{
if(animation._isUsingNativeDriver()){
animation._startNativeLoop(iterations);
}else{
restart();// Start looping recursively on the js thread
}
}
},

stop:function stop(){
isFinished=true;
animation.stop();
},

reset:function reset(){
iterationsSoFar=0;
isFinished=false;
animation.reset();
},

_startNativeLoop:function _startNativeLoop(){
throw new Error('Loops run using the native driver cannot contain Animated.loop animations');
},

_isUsingNativeDriver:function _isUsingNativeDriver(){
return animation._isUsingNativeDriver();
}};

};







function attachNativeEvent(viewRef,eventName,argMapping){
// Find animated values in `argMapping` and create an array representing their
// key path inside the `nativeEvent` object. Ex.: ['contentOffset', 'x'].
var eventMappings=[];

var traverse=function traverse(value,path){
if(value instanceof AnimatedValue){
value.__makeNative();

eventMappings.push({
nativeEventPath:path,
animatedValueTag:value.__getNativeTag()});

}else if(typeof value==='object'){
for(var _key5 in value){
traverse(value[_key5],path.concat(_key5));
}
}
};

invariant(
argMapping[0]&&argMapping[0].nativeEvent,
'Native driven events only support animated values contained inside `nativeEvent`.');


// Assume that the event containing `nativeEvent` is always the first argument.
traverse(argMapping[0].nativeEvent,[]);

var viewTag=ReactNative.findNodeHandle(viewRef);

eventMappings.forEach(function(mapping){
NativeAnimatedAPI.addAnimatedEventToView(viewTag,eventName,mapping);
});

return{
detach:function detach(){
eventMappings.forEach(function(mapping){
NativeAnimatedAPI.removeAnimatedEventFromView(
viewTag,
eventName,
mapping.animatedValueTag);

});
}};

}

function forkEvent(event,listener){
if(!event){
return listener;
}else if(event instanceof AnimatedEvent){
event.__addListener(listener);
return event;
}else{
return function(){
typeof event==='function'&&event.apply(undefined,arguments);
listener.apply(undefined,arguments);
};
}
}

function unforkEvent(event,listener){
if(event&&event instanceof AnimatedEvent){
event.__removeListener(listener);
}
}var

AnimatedEvent=function(){








function AnimatedEvent(
argMapping)

{var config=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};babelHelpers.classCallCheck(this,AnimatedEvent);this._listeners=[];
this._argMapping=argMapping;
if(config.listener){
this.__addListener(config.listener);
}
this._callListeners=this._callListeners.bind(this);
this._attachedEvent=null;
this.__isNative=shouldUseNativeDriver(config);




}babelHelpers.createClass(AnimatedEvent,[{key:"__addListener",value:function __addListener(

callback){
this._listeners.push(callback);
}},{key:"__removeListener",value:function __removeListener(

callback){
this._listeners=this._listeners.filter(function(listener){return listener!==callback;});
}},{key:"__attach",value:function __attach(

viewRef,eventName){
invariant(this.__isNative,'Only native driven events need to be attached.');

this._attachedEvent=attachNativeEvent(viewRef,eventName,this._argMapping);
}},{key:"__detach",value:function __detach(

viewTag,eventName){
invariant(this.__isNative,'Only native driven events need to be detached.');

this._attachedEvent&&this._attachedEvent.detach();
}},{key:"__getHandler",value:function __getHandler()

{var _this28=this;
if(this.__isNative){
return this._callListeners;
}

return function(){for(var _len=arguments.length,args=Array(_len),_key6=0;_key6<_len;_key6++){args[_key6]=arguments[_key6];}
var traverse=function traverse(recMapping,recEvt,key){
if(typeof recEvt==='number'&&recMapping instanceof AnimatedValue){
recMapping.setValue(recEvt);
}else if(typeof recMapping==='object'){
for(var mappingKey in recMapping){
traverse(recMapping[mappingKey],recEvt[mappingKey],mappingKey);
}
}
};

if(!_this28.__isNative){
_this28._argMapping.forEach(function(mapping,idx){
traverse(mapping,args[idx],'arg'+idx);
});
}
_this28._callListeners.apply(_this28,args);
};
}},{key:"_callListeners",value:function _callListeners()

{for(var _len2=arguments.length,args=Array(_len2),_key7=0;_key7<_len2;_key7++){args[_key7]=arguments[_key7];}
this._listeners.forEach(function(listener){return listener.apply(undefined,args);});
}},{key:"_validateMapping",value:function _validateMapping()

{
var traverse=function traverse(recMapping,recEvt,key){
if(typeof recEvt==='number'){
invariant(
recMapping instanceof AnimatedValue,
'Bad mapping of type '+typeof recMapping+' for key '+key+
', event value must map to AnimatedValue');

return;
}
invariant(
typeof recMapping==='object',
'Bad mapping of type '+typeof recMapping+' for key '+key);

invariant(
typeof recEvt==='object',
'Bad event of type '+typeof recEvt+' for key '+key);

for(var mappingKey in recMapping){
traverse(recMapping[mappingKey],recEvt[mappingKey],mappingKey);
}
};
}}]);return AnimatedEvent;}();


var event=function event(
argMapping,
config)
{
var animatedEvent=new AnimatedEvent(argMapping,config);
if(animatedEvent.__isNative){
return animatedEvent;
}else{
return animatedEvent.__getHandler();
}
};

/**
 * The `Animated` library is designed to make animations fluid, powerful, and
 * easy to build and maintain. `Animated` focuses on declarative relationships
 * between inputs and outputs, with configurable transforms in between, and
 * simple `start`/`stop` methods to control time-based animation execution.
 *
 * The simplest workflow for creating an animation is to to create an
 * `Animated.Value`, hook it up to one or more style attributes of an animated
 * component, and then drive updates via animations using `Animated.timing()`:
 *
 * ```javascript
 * Animated.timing(                            // Animate value over time
 *   this.state.fadeAnim,                      // The value to drive
 *   {
 *     toValue: 1,                             // Animate to final value of 1
 *   }
 * ).start();                                  // Start the animation
 * ```
 *
 * Refer to the [Animations](docs/animations.html#animated-api) guide to see
 * additional examples of `Animated` in action.
 *
 * ## Overview
 *
 * There are two value types you can use with `Animated`:
 *
 * - [`Animated.Value()`](docs/animated.html#value) for single values
 * - [`Animated.ValueXY()`](docs/animated.html#valuexy) for vectors
 *
 * `Animated.Value` can bind to style properties or other props, and can be
 * interpolated as well. A single `Animated.Value` can drive any number of
 * properties.
 *
 * ### Configuring animations
 *
 * `Animated` provides three types of animation types. Each animation type
 * provides a particular animation curve that controls how your values animate
 * from their initial value to the final value:
 *
 * - [`Animated.decay()`](docs/animated.html#decay) starts with an initial
 *   velocity and gradually slows to a stop.
 * - [`Animated.spring()`](docs/animated.html#spring) provides a simple
 *   spring physics model.
 * - [`Animated.timing()`](docs/animated.html#timing) animates a value over time
 *   using [easing functions](docs/easing.html).
 *
 * In most cases, you will be using `timing()`. By default, it uses a symmetric
 * easeInOut curve that conveys the gradual acceleration of an object to full
 * speed and concludes by gradually decelerating to a stop.
 *
 * ### Working with animations
 *
 * Animations are started by calling `start()` on your animation. `start()`
 * takes a completion callback that will be called when the animation is done.
 * If the animation finished running normally, the completion callback will be
 * invoked with `{finished: true}`. If the animation is done because `stop()`
 * was called on it before it could finish (e.g. because it was interrupted by a
 * gesture or another animation), then it will receive `{finished: false}`.
 *
 * ### Using the native driver
 *
 * By using the native driver, we send everything about the animation to native
 * before starting the animation, allowing native code to perform the animation
 * on the UI thread without having to go through the bridge on every frame.
 * Once the animation has started, the JS thread can be blocked without
 * affecting the animation.
 *
 * You can use the native driver by specifying `useNativeDriver: true` in your
 * animation configuration. See the
 * [Animations](docs/animations.html#using-the-native-driver) guide to learn
 * more.
 *
 * ### Animatable components
 *
 * Only animatable components can be animated. These special components do the
 * magic of binding the animated values to the properties, and do targeted
 * native updates to avoid the cost of the react render and reconciliation
 * process on every frame. They also handle cleanup on unmount so they are safe
 * by default.
 *
 * - [`createAnimatedComponent()`](docs/animated.html#createanimatedcomponent)
 *   can be used to make a component animatable.
 *
 * `Animated` exports the following animatable components using the above
 * wrapper:
 *
 * - `Animated.Image`
 * - `Animated.ScrollView`
 * - `Animated.Text`
 * - `Animated.View`
 *
 * ### Composing animations
 *
 * Animations can also be combined in complex ways using composition functions:
 *
 * - [`Animated.delay()`](docs/animated.html#delay) starts an animation after
 *   a given delay.
 * - [`Animated.parallel()`](docs/animated.html#parallel) starts a number of
 *   animations at the same time.
 * - [`Animated.sequence()`](docs/animated.html#sequence) starts the animations
 *   in order, waiting for each to complete before starting the next.
 * - [`Animated.stagger()`](docs/animated.html#stagger) starts animations in
 *   order and in parallel, but with successive delays.
 *
 * Animations can also be chained together simply by setting the `toValue` of
 * one animation to be another `Animated.Value`. See
 * [Tracking dynamic values](docs/animations.html#tracking-dynamic-values) in
 * the Animations guide.
 *
 * By default, if one animation is stopped or interrupted, then all other
 * animations in the group are also stopped.
 *
 * ### Combining animated values
 *
 * You can combine two animated values via addition, multiplication, division,
 * or modulo to make a new animated value:
 *
 * - [`Animated.add()`](docs/animated.html#add)
 * - [`Animated.divide()`](docs/animated.html#divide)
 * - [`Animated.modulo()`](docs/animated.html#modulo)
 * - [`Animated.multiply()`](docs/animated.html#multiply)
 *
 * ### Interpolation
 *
 * The `interpolate()` function allows input ranges to map to different output
 * ranges. By default, it will extrapolate the curve beyond the ranges given,
 * but you can also have it clamp the output value. It uses lineal interpolation
 * by default but also supports easing functions.
 *
 * - [`interpolate()`](docs/animated.html#interpolate)
 *
 * Read more about interpolation in the
 * [Animation](docs/animations.html#interpolation) guide.
 *
 * ### Handling gestures and other events
 *
 * Gestures, like panning or scrolling, and other events can map directly to
 * animated values using `Animated.event()`. This is done with a structured map
 * syntax so that values can be extracted from complex event objects. The first
 * level is an array to allow mapping across multiple args, and that array
 * contains nested objects.
 *
 * - [`Animated.event()`](docs/animated.html#event)
 *
 * For example, when working with horizontal scrolling gestures, you would do
 * the following in order to map `event.nativeEvent.contentOffset.x` to
 * `scrollX` (an `Animated.Value`):
 *
 * ```javascript
 *  onScroll={Animated.event(
 *    // scrollX = e.nativeEvent.contentOffset.x
 *    [{ nativeEvent: {
 *         contentOffset: {
 *           x: scrollX
 *         }
 *       }
 *     }]
 *  )}
 * ```
 *
 */
module.exports={
/**
   * Standard value class for driving animations.  Typically initialized with
   * `new Animated.Value(0);`
   *
   * See also [`AnimatedValue`](docs/animated.html#animatedvalue).
   */
Value:AnimatedValue,

/**
   * base class of animated value
   */
ValueBase:Animated,

/**
   * base class for composite of animated values
   */
ValueComposite:AnimatedWithChildren,

/**
   * 2D value class for driving 2D animations, such as pan gestures.
   *
   * See also [`AnimatedValueXY`](docs/animated.html#animatedvaluexy).
   */
ValueXY:AnimatedValueXY,
/**
   * 3D value class for driving animations in 3D space.
   *
   * TODO: Add documentation
   */
ValueVec3:AnimatedValueVec3,
/**
   * exported to use the Interpolation type in flow
   *
   * See also [`AnimatedInterpolation`](docs/animated.html#animatedinterpolation).
   */
Interpolation:AnimatedInterpolation,

/**
   * Animates a value from an initial velocity to zero based on a decay
   * coefficient.
   *
   * Config is an object that may have the following options:
   *
   *   - `velocity`: Initial velocity.  Required.
   *   - `deceleration`: Rate of decay.  Default 0.997.
   *   - `useNativeDriver`: Uses the native driver when true. Default false.
   */
decay:decay,
/**
   * Animates a value along a timed easing curve. The
   * [`Easing`](docs/easing.html) module has tons of predefined curves, or you
   * can use your own function.
   *
   * Config is an object that may have the following options:
   *
   *   - `duration`: Length of animation (milliseconds).  Default 500.
   *   - `easing`: Easing function to define curve.
   *     Default is `Easing.inOut(Easing.ease)`.
   *   - `delay`: Start the animation after delay (milliseconds).  Default 0.
   *   - `useNativeDriver`: Uses the native driver when true. Default false.
   */
timing:timing,
/**
   * Spring animation based on Rebound and
   * [Origami](https://facebook.github.io/origami/).  Tracks velocity state to
   * create fluid motions as the `toValue` updates, and can be chained together.
   *
   * Config is an object that may have the following options:
   *
   *   - `friction`: Controls "bounciness"/overshoot.  Default 7.
   *   - `tension`: Controls speed.  Default 40.
   *   - `useNativeDriver`: Uses the native driver when true. Default false.
   */
spring:spring,

/**
   * Creates a new Animated value composed from two Animated values added
   * together.
   */
add:add,

/**
   * Creates a new Animated value composed by dividing the first Animated value
   * by the second Animated value.
   */
divide:divide,

/**
   * Creates a new Animated value composed from two Animated values multiplied
   * together.
   */
multiply:multiply,

/**
   * Creates a new Animated value that is the (non-negative) modulo of the
   * provided Animated value
   */
modulo:modulo,

/**
   * Create a new Animated value that is limited between 2 values. It uses the
   * difference between the last value so even if the value is far from the bounds
   * it will start changing when the value starts getting closer again.
   * (`value = clamp(value + diff, min, max)`).
   *
   * This is useful with scroll events, for example, to show the navbar when
   * scrolling up and to hide it when scrolling down.
   */
diffClamp:diffClamp,

/**
   * Starts an animation after the given delay.
   */
delay:delay,
/**
   * Starts an array of animations in order, waiting for each to complete
   * before starting the next.  If the current running animation is stopped, no
   * following animations will be started.
   */
sequence:sequence,
/**
   * Starts an array of animations all at the same time.  By default, if one
   * of the animations is stopped, they will all be stopped.  You can override
   * this with the `stopTogether` flag.
   */
parallel:parallel,
/**
   * Array of animations may run in parallel (overlap), but are started in
   * sequence with successive delays.  Nice for doing trailing effects.
   */
stagger:stagger,
/**
  * Loops a given animation continuously, so that each time it reaches the
  * end, it resets and begins again from the start. Can specify number of
  * times to loop using the key 'iterations' in the config. Will loop without
  * blocking the UI thread if the child animation is set to 'useNativeDriver'.
  */
loop:loop,

/**
   * Takes an array of mappings and extracts values from each arg accordingly,
   * then calls `setValue` on the mapped outputs.  e.g.
   *
   *```javascript
   *  onScroll={Animated.event(
   *    [{nativeEvent: {contentOffset: {x: this._scrollX}}}]
   *    {listener},          // Optional async listener
   *  )
   *  ...
   *  onPanResponderMove: Animated.event([
   *    null,                // raw event arg ignored
   *    {dx: this._panX},    // gestureState arg
   *  ]),
   *```
   *
   * Config is an object that may have the following options:
   *
   *   - `listener`: Optional async listener.
   *   - `useNativeDriver`: Uses the native driver when true. Default false.
   */
event:event,

/**
   * Make any React component Animatable.  Used to create `Animated.View`, etc.
   */
createAnimatedComponent:createAnimatedComponent,

/**
   * Imperative API to attach an animated value to an event on a view. Prefer using
   * `Animated.event` with `useNativeDrive: true` if possible.
   */
attachNativeEvent:attachNativeEvent,

/**
   * Advanced imperative API for snooping on animated events that are passed in through props. Use
   * values directly where possible.
   */
forkEvent:forkEvent,
unforkEvent:unforkEvent,

__PropsOnlyForTests:AnimatedProps};